/* 
  This file was generated by KreMLin <https://github.com/FStarLang/kremlin>
  KreMLin invocation: /Users/bhargava/Desktop/repositories/kremlin/krml -fbuiltin-uint128 -fnocompound-literals -fc89-scope -fparentheses -fcurly-braces -funroll-loops 8 -warn-error +9 -add-include "kremlib.h" -add-include "FStar_UInt_8_16_32_64.h" /dist/minimal/testlib.c -skip-compilation -bundle Lib.* -bundle Spec.\* -bundle MPFR=* -bundle FStar.* -drop Lib.IntVector.Intrinsics,LowStar,Spec,Prims,Lib,C.Loops.*,Hacl.Spec.* -tmpdir mpfr-c .output/prims.krml .output/FStar_Pervasives_Native.krml .output/FStar_Pervasives.krml .output/FStar_Mul.krml .output/FStar_Preorder.krml .output/FStar_Calc.krml .output/FStar_Squash.krml .output/FStar_Classical.krml .output/FStar_StrongExcludedMiddle.krml .output/FStar_FunctionalExtensionality.krml .output/FStar_List_Tot_Base.krml .output/FStar_List_Tot_Properties.krml .output/FStar_List_Tot.krml .output/FStar_Seq_Base.krml .output/FStar_Seq_Properties.krml .output/FStar_Seq.krml .output/FStar_Math_Lib.krml .output/FStar_Math_Lemmas.krml .output/FStar_BitVector.krml .output/FStar_UInt.krml .output/FStar_UInt32.krml .output/FStar_Int.krml .output/FStar_Int64.krml .output/FStar_Int63.krml .output/FStar_Int32.krml .output/FStar_Int16.krml .output/FStar_Int8.krml .output/FStar_UInt64.krml .output/FStar_UInt63.krml .output/FStar_UInt16.krml .output/FStar_UInt8.krml .output/FStar_Int_Cast.krml .output/FStar_UInt128.krml .output/MPFR_Umul_ppmm.krml .output/FStar_Reflection_Types.krml .output/FStar_Reflection_Data.krml .output/FStar_Order.krml .output/FStar_Reflection_Basic.krml .output/FStar_Ghost.krml .output/FStar_ErasedLogic.krml .output/MPFR_Maths.krml .output/MPFR_Dyadic.krml .output/MPFR_RoundingMode.krml .output/MPFR_Lib_Spec.krml .output/MPFR_Round_Spec.krml .output/MPFR_Add1_Spec.krml .output/FStar_Set.krml .output/FStar_PropositionalExtensionality.krml .output/FStar_PredicateExtensionality.krml .output/FStar_TSet.krml .output/FStar_Monotonic_Heap.krml .output/FStar_Heap.krml .output/FStar_Map.krml .output/FStar_Monotonic_Witnessed.krml .output/FStar_Monotonic_HyperHeap.krml .output/FStar_Monotonic_HyperStack.krml .output/FStar_HyperStack.krml .output/FStar_HyperStack_ST.krml .output/FStar_Buffer.krml .output/FStar_HyperStack_All.krml .output/MPFR_Lib.krml .output/MPFR_Add1sp1_Lemma.krml .output/FStar_Exn.krml .output/FStar_ST.krml .output/FStar_All.krml .output/FStar_List.krml .output/FStar_Char.krml .output/FStar_String.krml .output/FStar_Universe.krml .output/FStar_GSet.krml .output/FStar_ModifiesGen.krml .output/FStar_Range.krml .output/FStar_Tactics_Types.krml .output/FStar_Tactics_Result.krml .output/FStar_Tactics_Effect.krml .output/FStar_Tactics_Util.krml .output/FStar_Reflection_Const.krml .output/FStar_Reflection_Derived.krml .output/FStar_Tactics_Builtins.krml .output/FStar_Reflection_Formula.krml .output/FStar_Reflection_Derived_Lemmas.krml .output/FStar_Reflection.krml .output/FStar_Tactics_Derived.krml .output/FStar_Tactics_Logic.krml .output/FStar_Tactics.krml .output/FStar_BigOps.krml .output/LowStar_Monotonic_Buffer.krml .output/LowStar_Buffer.krml .output/LowStar_BufferOps.krml .output/FStar_Kremlin_Endianness.krml .output/C_Endianness.krml .output/C.krml .output/LowStar_Modifies.krml .output/C_String.krml .output/MPFR_Exceptions_Lemma.krml .output/MPFR_Exceptions.krml .output/MPFR_Mul_Spec.krml .output/MPFR_Mul_1.krml .output/MPFR_Add1sp1.krml .output/MPFR.krml .output/FStar_HyperStack_IO.krml .output/Test_MPFR.krml
  F* version: 731d7fa9
  KreMLin version: 0aca989d
 */

#include "MPFR.h"

extern uint128_t FStar_UInt128_shift_right(uint128_t a, uint32_t s);

extern uint64_t FStar_UInt128_uint128_to_uint64(uint128_t a);

extern uint128_t FStar_UInt128_mul_wide(uint64_t x, uint64_t y);

typedef struct K___uint64_t_uint64_t_s
{
  uint64_t fst;
  uint64_t snd;
}
K___uint64_t_uint64_t;

static K___uint64_t_uint64_t MPFR_Umul_ppmm_umul_ppmm(uint64_t m, uint64_t n1)
{
  uint128_t p = (uint128_t)m * n1;
  K___uint64_t_uint64_t lit;
  lit.fst = (uint64_t)(p >> (uint32_t)64U);
  lit.snd = (uint64_t)p;
  return lit;
}

static bool MPFR_RoundingMode_uu___is_MPFR_RNDN(MPFR_RoundingMode_mpfr_rnd_t projectee)
{
  switch (projectee)
  {
    case MPFR_RoundingMode_MPFR_RNDN:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

static bool MPFR_RoundingMode_uu___is_MPFR_RNDZ(MPFR_RoundingMode_mpfr_rnd_t projectee)
{
  switch (projectee)
  {
    case MPFR_RoundingMode_MPFR_RNDZ:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

static bool MPFR_RoundingMode_uu___is_MPFR_RNDU(MPFR_RoundingMode_mpfr_rnd_t projectee)
{
  switch (projectee)
  {
    case MPFR_RoundingMode_MPFR_RNDU:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

static bool MPFR_RoundingMode_uu___is_MPFR_RNDD(MPFR_RoundingMode_mpfr_rnd_t projectee)
{
  switch (projectee)
  {
    case MPFR_RoundingMode_MPFR_RNDD:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

static bool MPFR_RoundingMode_uu___is_MPFR_RNDA(MPFR_RoundingMode_mpfr_rnd_t projectee)
{
  switch (projectee)
  {
    case MPFR_RoundingMode_MPFR_RNDA:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

static bool MPFR_RoundingMode_mpfr_IS_LIKE_RNDZ(MPFR_RoundingMode_mpfr_rnd_t rnd, bool neg)
{
  return
    MPFR_RoundingMode_uu___is_MPFR_RNDZ(rnd)
    || (MPFR_RoundingMode_uu___is_MPFR_RNDU(rnd) && neg)
    || (MPFR_RoundingMode_uu___is_MPFR_RNDD(rnd) && !neg);
}

static bool MPFR_RoundingMode_mpfr_IS_LIKE_RNDA(MPFR_RoundingMode_mpfr_rnd_t rnd, bool neg)
{
  return
    MPFR_RoundingMode_uu___is_MPFR_RNDA(rnd)
    || (MPFR_RoundingMode_uu___is_MPFR_RNDD(rnd) && neg)
    || (MPFR_RoundingMode_uu___is_MPFR_RNDD(rnd) && !neg);
}

static int64_t MPFR_Lib_gmp_NUMB_BITS = (int64_t)64;

static int64_t MPFR_Lib_mpfr_EXP_ZERO = (int64_t)-0x7fffffffffffffff;

static int64_t MPFR_Lib_mpfr_EXP_INF = (int64_t)-0x7ffffffffffffffd;

static int64_t MPFR_Lib_mpfr_EMIN = (int64_t)-0x000000003fffffff;

static int64_t MPFR_Lib_mpfr_EMAX = (int64_t)0x000000003fffffff;

static void MPFR_Lib_mpfr_SET_EXP(MPFR_Lib_mpfr_struct *x, int64_t e)
{
  MPFR_Lib_mpfr_struct uu____0 = x[0U];
  MPFR_Lib_mpfr_struct lit;
  lit.mpfr_prec = uu____0.mpfr_prec;
  lit.mpfr_sign = uu____0.mpfr_sign;
  lit.mpfr_exp = e;
  lit.mpfr_d = uu____0.mpfr_d;
  x[0U] = lit;
}

static int32_t MPFR_Lib_mpfr_NEG_SIGN(int32_t s)
{
  if (s == (int32_t)1)
  {
    return (int32_t)-1;
  }
  else
  {
    return (int32_t)1;
  }
}

static void MPFR_Lib_mpn_ZERO(uint64_t *b, int64_t l)
{
  if (!(l == (int64_t)0))
  {
    b[(uint32_t)(l - (int64_t)1)] = (uint64_t)0U;
    MPFR_Lib_mpn_ZERO(b, l - (int64_t)1);
  }
}

static int32_t MPFR_Lib_mpfr_RET(int32_t t)
{
  return t;
}

static void MPFR_Lib_mpfr_setmax_rec(MPFR_Lib_mpfr_struct *x, int64_t i)
{
  uint64_t *mant = x->mpfr_d;
  if (i == (int64_t)0)
  {
    MPFR_Lib_mpfr_struct f0 = x[0U];
    int64_t p = f0.mpfr_prec;
    MPFR_Lib_mpfr_struct f = x[0U];
    int64_t l = (f.mpfr_prec - (int64_t)1) / MPFR_Lib_gmp_NUMB_BITS + (int64_t)1;
    mant[(uint32_t)i] = (uint64_t)0xffffffffffffffffU << (uint32_t)(l * MPFR_Lib_gmp_NUMB_BITS - p);
  }
  else
  {
    MPFR_Lib_mpfr_setmax_rec(x, i - (int64_t)1);
    mant[(uint32_t)i] = (uint64_t)0xffffffffffffffffU;
  }
}

static void MPFR_Lib_mpfr_setmax(MPFR_Lib_mpfr_struct *x)
{
  MPFR_Lib_mpfr_struct f;
  MPFR_Lib_mpfr_SET_EXP(x, MPFR_Lib_mpfr_EMAX);
  f = x[0U];
  MPFR_Lib_mpfr_setmax_rec(x, (f.mpfr_prec - (int64_t)1) / MPFR_Lib_gmp_NUMB_BITS);
}

static void MPFR_Lib_mpfr_setmin(MPFR_Lib_mpfr_struct *x)
{
  MPFR_Lib_mpfr_struct f;
  int64_t xn;
  uint64_t *xp;
  MPFR_Lib_mpfr_SET_EXP(x, MPFR_Lib_mpfr_EMIN);
  f = x[0U];
  xn = (f.mpfr_prec - (int64_t)1) / MPFR_Lib_gmp_NUMB_BITS;
  xp = x->mpfr_d;
  xp[(uint32_t)xn] = (uint64_t)0x8000000000000000U;
  MPFR_Lib_mpn_ZERO(xp, xn);
}

static int32_t
MPFR_Exceptions_mpfr_overflow(
  MPFR_Lib_mpfr_struct *x,
  MPFR_RoundingMode_mpfr_rnd_t rnd_mode,
  int32_t sign
)
{
  MPFR_Lib_mpfr_struct uu____0 = x[0U];
  MPFR_Lib_mpfr_struct lit;
  int32_t ite;
  lit.mpfr_prec = uu____0.mpfr_prec;
  lit.mpfr_sign = sign;
  lit.mpfr_exp = uu____0.mpfr_exp;
  lit.mpfr_d = uu____0.mpfr_d;
  x[0U] = lit;
  if (MPFR_RoundingMode_mpfr_IS_LIKE_RNDZ(rnd_mode, sign < (int32_t)0))
  {
    MPFR_Lib_mpfr_setmax(x);
    ite = MPFR_Lib_mpfr_NEG_SIGN(sign);
  }
  else
  {
    MPFR_Lib_mpfr_SET_EXP(x, MPFR_Lib_mpfr_EXP_INF);
    ite = sign;
  }
  return ite;
}

static int32_t
MPFR_Exceptions_mpfr_underflow(
  MPFR_Lib_mpfr_struct *x,
  MPFR_RoundingMode_mpfr_rnd_t rnd_mode,
  int32_t sign
)
{
  MPFR_Lib_mpfr_struct uu____0 = x[0U];
  MPFR_Lib_mpfr_struct lit;
  int32_t ite;
  lit.mpfr_prec = uu____0.mpfr_prec;
  lit.mpfr_sign = sign;
  lit.mpfr_exp = uu____0.mpfr_exp;
  lit.mpfr_d = uu____0.mpfr_d;
  x[0U] = lit;
  if (MPFR_RoundingMode_mpfr_IS_LIKE_RNDZ(rnd_mode, sign < (int32_t)0))
  {
    MPFR_Lib_mpfr_SET_EXP(x, MPFR_Lib_mpfr_EXP_ZERO);
    ite = MPFR_Lib_mpfr_NEG_SIGN(sign);
  }
  else
  {
    MPFR_Lib_mpfr_setmin(x);
    ite = sign;
  }
  return ite;
}

typedef struct K___int64_t_uint64_t_uint64_t_s
{
  int64_t fst;
  uint64_t snd;
  uint64_t thd;
}
K___int64_t_uint64_t_uint64_t;

static int32_t
MPFR_Mul_1_mpfr_mul_1(
  MPFR_Lib_mpfr_struct *a,
  MPFR_Lib_mpfr_struct *b,
  MPFR_Lib_mpfr_struct *c,
  MPFR_RoundingMode_mpfr_rnd_t rnd_mode,
  int64_t p
)
{
  uint64_t *ap = a->mpfr_d;
  uint64_t *bp = b->mpfr_d;
  uint64_t *cp = c->mpfr_d;
  uint64_t b0 = bp[0U];
  uint64_t c0 = cp[0U];
  int64_t sh = MPFR_Lib_gmp_NUMB_BITS - p;
  uint64_t mask = ((uint64_t)1U << (uint32_t)sh) - (uint64_t)1U;
  int64_t ax = b->mpfr_exp + c->mpfr_exp;
  K___uint64_t_uint64_t scrut0 = MPFR_Umul_ppmm_umul_ppmm(b0, c0);
  uint64_t a0 = scrut0.fst;
  uint64_t sb = scrut0.snd;
  K___int64_t_uint64_t_uint64_t scrut;
  if (a0 < (uint64_t)0x8000000000000000U)
  {
    K___int64_t_uint64_t_uint64_t lit;
    lit.fst = ax - (int64_t)1;
    lit.snd = a0 << (uint32_t)1U | sb >> (uint32_t)(MPFR_Lib_gmp_NUMB_BITS - (int64_t)1);
    lit.thd = sb << (uint32_t)1U;
    scrut = lit;
  }
  else
  {
    K___int64_t_uint64_t_uint64_t lit;
    lit.fst = ax;
    lit.snd = a0;
    lit.thd = sb;
    scrut = lit;
  }
  {
    int64_t ax1 = scrut.fst;
    uint64_t a01 = scrut.snd;
    uint64_t sb1 = scrut.thd;
    uint64_t rb = a01 & (uint64_t)1U << (uint32_t)(sh - (int64_t)1);
    uint64_t sb2 = sb1 | ((a01 & mask) ^ rb);
    MPFR_Lib_mpfr_struct uu____0;
    ap[0U] = a01 & ~mask;
    uu____0 = a[0U];
    {
      MPFR_Lib_mpfr_struct lit;
      uint64_t *ap1;
      uint64_t a02;
      int32_t ite;
      lit.mpfr_prec = uu____0.mpfr_prec;
      lit.mpfr_sign = b->mpfr_sign * c->mpfr_sign;
      lit.mpfr_exp = uu____0.mpfr_exp;
      lit.mpfr_d = uu____0.mpfr_d;
      a[0U] = lit;
      ap1 = a->mpfr_d;
      a02 = ap1[0U];
      if (ax1 > MPFR_Lib_mpfr_EMAX)
      {
        ite = MPFR_Exceptions_mpfr_overflow(a, rnd_mode, a->mpfr_sign);
      }
      else if (ax1 < MPFR_Lib_mpfr_EMIN)
      {
        bool aneg = a->mpfr_sign < (int32_t)0;
        if
        (
          ax1
          == MPFR_Lib_mpfr_EMIN - (int64_t)1
          && a02 == ~mask
          &&
            ((MPFR_RoundingMode_uu___is_MPFR_RNDN(rnd_mode) && rb > (uint64_t)0U)
            || ((rb | sb2) > (uint64_t)0U && MPFR_RoundingMode_mpfr_IS_LIKE_RNDA(rnd_mode, aneg)))
        )
        {
          uint64_t *ap2 = a->mpfr_d;
          uint64_t a03 = ap2[0U];
          MPFR_Lib_mpfr_SET_EXP(a, ax1);
          if (rb == (uint64_t)0U && sb2 == (uint64_t)0U)
          {
            ite = MPFR_Lib_mpfr_RET((int32_t)0);
          }
          else if (MPFR_RoundingMode_uu___is_MPFR_RNDN(rnd_mode))
          {
            if
            (
              rb
              == (uint64_t)0U
              || (sb2 == (uint64_t)0U && (a03 & (uint64_t)1U << (uint32_t)sh) == (uint64_t)0U)
            )
            {
              ite = MPFR_Lib_mpfr_RET(MPFR_Lib_mpfr_NEG_SIGN(a->mpfr_sign));
            }
            else
            {
              uint64_t *ap3 = a->mpfr_d;
              ap3[0U] = ap3[0U] + ((uint64_t)1U << (uint32_t)sh);
              if (ap3[0U] == (uint64_t)0U)
              {
                ap3[0U] = (uint64_t)0x8000000000000000U;
                if (ax1 + (int64_t)1 > MPFR_Lib_mpfr_EMAX)
                {
                  ite = MPFR_Exceptions_mpfr_overflow(a, rnd_mode, a->mpfr_sign);
                }
                else
                {
                  MPFR_Lib_mpfr_SET_EXP(a, ax1 + (int64_t)1);
                  ite = MPFR_Lib_mpfr_RET(a->mpfr_sign);
                }
              }
              else
              {
                ite = MPFR_Lib_mpfr_RET(a->mpfr_sign);
              }
            }
          }
          else if (MPFR_RoundingMode_mpfr_IS_LIKE_RNDZ(rnd_mode, a->mpfr_sign < (int32_t)0))
          {
            ite = MPFR_Lib_mpfr_RET(MPFR_Lib_mpfr_NEG_SIGN(a->mpfr_sign));
          }
          else
          {
            uint64_t *ap3 = a->mpfr_d;
            ap3[0U] = ap3[0U] + ((uint64_t)1U << (uint32_t)sh);
            if (ap3[0U] == (uint64_t)0U)
            {
              ap3[0U] = (uint64_t)0x8000000000000000U;
              if (ax1 + (int64_t)1 > MPFR_Lib_mpfr_EMAX)
              {
                ite = MPFR_Exceptions_mpfr_overflow(a, rnd_mode, a->mpfr_sign);
              }
              else
              {
                MPFR_Lib_mpfr_SET_EXP(a, ax1 + (int64_t)1);
                ite = MPFR_Lib_mpfr_RET(a->mpfr_sign);
              }
            }
            else
            {
              ite = MPFR_Lib_mpfr_RET(a->mpfr_sign);
            }
          }
        }
        else if
        (
          MPFR_RoundingMode_uu___is_MPFR_RNDN(rnd_mode)
          &&
            (ax1
            < MPFR_Lib_mpfr_EMIN - (int64_t)1
            || (a02 == (uint64_t)0x8000000000000000U && (rb | sb2) == (uint64_t)0U))
        )
        {
          ite = MPFR_Exceptions_mpfr_underflow(a, MPFR_RoundingMode_MPFR_RNDZ, a->mpfr_sign);
        }
        else
        {
          ite = MPFR_Exceptions_mpfr_underflow(a, rnd_mode, a->mpfr_sign);
        }
      }
      else
      {
        uint64_t *ap2 = a->mpfr_d;
        uint64_t a03 = ap2[0U];
        MPFR_Lib_mpfr_SET_EXP(a, ax1);
        if (rb == (uint64_t)0U && sb2 == (uint64_t)0U)
        {
          ite = MPFR_Lib_mpfr_RET((int32_t)0);
        }
        else if (MPFR_RoundingMode_uu___is_MPFR_RNDN(rnd_mode))
        {
          if
          (
            rb
            == (uint64_t)0U
            || (sb2 == (uint64_t)0U && (a03 & (uint64_t)1U << (uint32_t)sh) == (uint64_t)0U)
          )
          {
            ite = MPFR_Lib_mpfr_RET(MPFR_Lib_mpfr_NEG_SIGN(a->mpfr_sign));
          }
          else
          {
            uint64_t *ap3 = a->mpfr_d;
            ap3[0U] = ap3[0U] + ((uint64_t)1U << (uint32_t)sh);
            if (ap3[0U] == (uint64_t)0U)
            {
              ap3[0U] = (uint64_t)0x8000000000000000U;
              if (ax1 + (int64_t)1 > MPFR_Lib_mpfr_EMAX)
              {
                ite = MPFR_Exceptions_mpfr_overflow(a, rnd_mode, a->mpfr_sign);
              }
              else
              {
                MPFR_Lib_mpfr_SET_EXP(a, ax1 + (int64_t)1);
                ite = MPFR_Lib_mpfr_RET(a->mpfr_sign);
              }
            }
            else
            {
              ite = MPFR_Lib_mpfr_RET(a->mpfr_sign);
            }
          }
        }
        else if (MPFR_RoundingMode_mpfr_IS_LIKE_RNDZ(rnd_mode, a->mpfr_sign < (int32_t)0))
        {
          ite = MPFR_Lib_mpfr_RET(MPFR_Lib_mpfr_NEG_SIGN(a->mpfr_sign));
        }
        else
        {
          uint64_t *ap3 = a->mpfr_d;
          ap3[0U] = ap3[0U] + ((uint64_t)1U << (uint32_t)sh);
          if (ap3[0U] == (uint64_t)0U)
          {
            ap3[0U] = (uint64_t)0x8000000000000000U;
            if (ax1 + (int64_t)1 > MPFR_Lib_mpfr_EMAX)
            {
              ite = MPFR_Exceptions_mpfr_overflow(a, rnd_mode, a->mpfr_sign);
            }
            else
            {
              MPFR_Lib_mpfr_SET_EXP(a, ax1 + (int64_t)1);
              ite = MPFR_Lib_mpfr_RET(a->mpfr_sign);
            }
          }
          else
          {
            ite = MPFR_Lib_mpfr_RET(a->mpfr_sign);
          }
        }
      }
      return ite;
    }
  }
}

typedef struct MPFR_Add1sp1_state_s
{
  int64_t sh;
  int64_t bx;
  uint64_t rb;
  uint64_t sb;
}
MPFR_Add1sp1_state;

static MPFR_Add1sp1_state
MPFR_Add1sp1_mk_state(int64_t sh, int64_t bx, uint64_t rb, uint64_t sb)
{
  MPFR_Add1sp1_state lit;
  lit.sh = sh;
  lit.bx = bx;
  lit.rb = rb;
  lit.sb = sb;
  return lit;
}

typedef struct K___uint64_t_int64_t_s
{
  uint64_t fst;
  int64_t snd;
}
K___uint64_t_int64_t;

typedef struct K___uint64_t_uint64_t_int64_t_s
{
  uint64_t fst;
  uint64_t snd;
  int64_t thd;
}
K___uint64_t_uint64_t_int64_t;

static int32_t
MPFR_Add1sp1_mpfr_add1sp1(
  MPFR_Lib_mpfr_struct *a,
  MPFR_Lib_mpfr_struct *b,
  MPFR_Lib_mpfr_struct *c,
  MPFR_RoundingMode_mpfr_rnd_t rnd_mode,
  int64_t p
)
{
  uint64_t *ap = a->mpfr_d;
  int64_t bx = b->mpfr_exp;
  int64_t cx = c->mpfr_exp;
  uint64_t *bp = b->mpfr_d;
  uint64_t *cp = c->mpfr_d;
  int64_t sh = MPFR_Lib_gmp_NUMB_BITS - p;
  MPFR_Add1sp1_state st;
  if (bx == cx)
  {
    uint64_t a0 = (bp[0U] >> (uint32_t)1U) + (cp[0U] >> (uint32_t)1U);
    int64_t bx1 = bx + (int64_t)1;
    uint64_t rb = a0 & (uint64_t)1U << (uint32_t)(sh - (int64_t)1);
    ap[0U] = a0 ^ rb;
    {
      uint64_t sb = (uint64_t)0U;
      st = MPFR_Add1sp1_mk_state(sh, bx1, rb, sb);
    }
  }
  else if (bx > cx)
  {
    int64_t d = bx - cx;
    uint64_t mask = ((uint64_t)1U << (uint32_t)sh) - (uint64_t)1U;
    if (d < sh)
    {
      uint64_t a0 = bp[0U] + (cp[0U] >> (uint32_t)d);
      K___uint64_t_int64_t scrut;
      if (a0 < bp[0U])
      {
        K___uint64_t_int64_t lit;
        lit.fst = (uint64_t)0x8000000000000000U | a0 >> (uint32_t)1U;
        lit.snd = bx + (int64_t)1;
        scrut = lit;
      }
      else
      {
        K___uint64_t_int64_t lit;
        lit.fst = a0;
        lit.snd = bx;
        scrut = lit;
      }
      {
        uint64_t a01 = scrut.fst;
        int64_t bx1 = scrut.snd;
        uint64_t rb = a01 & (uint64_t)1U << (uint32_t)(sh - (int64_t)1);
        uint64_t sb = (a01 & mask) ^ rb;
        ap[0U] = a01 & ~mask;
        st = MPFR_Add1sp1_mk_state(sh, bx1, rb, sb);
      }
    }
    else if (d < MPFR_Lib_gmp_NUMB_BITS)
    {
      uint64_t sb = cp[0U] << (uint32_t)(MPFR_Lib_gmp_NUMB_BITS - d);
      uint64_t a0 = bp[0U] + (cp[0U] >> (uint32_t)d);
      K___uint64_t_uint64_t_int64_t scrut;
      if (a0 < bp[0U])
      {
        K___uint64_t_uint64_t_int64_t lit;
        lit.fst = sb | (a0 & (uint64_t)1U);
        lit.snd = (uint64_t)0x8000000000000000U | a0 >> (uint32_t)1U;
        lit.thd = bx + (int64_t)1;
        scrut = lit;
      }
      else
      {
        K___uint64_t_uint64_t_int64_t lit;
        lit.fst = sb;
        lit.snd = a0;
        lit.thd = bx;
        scrut = lit;
      }
      {
        uint64_t sb1 = scrut.fst;
        uint64_t a01 = scrut.snd;
        int64_t bx1 = scrut.thd;
        uint64_t rb = a01 & (uint64_t)1U << (uint32_t)(sh - (int64_t)1);
        uint64_t sb2 = sb1 | ((a01 & mask) ^ rb);
        ap[0U] = a01 & ~mask;
        st = MPFR_Add1sp1_mk_state(sh, bx1, rb, sb2);
      }
    }
    else
    {
      ap[0U] = bp[0U];
      {
        uint64_t rb = (uint64_t)0U;
        uint64_t sb = (uint64_t)1U;
        st = MPFR_Add1sp1_mk_state(sh, bx, rb, sb);
      }
    }
  }
  else
  {
    int64_t d = cx - bx;
    uint64_t mask = ((uint64_t)1U << (uint32_t)sh) - (uint64_t)1U;
    if (d < sh)
    {
      uint64_t a0 = cp[0U] + (bp[0U] >> (uint32_t)d);
      K___uint64_t_int64_t scrut;
      if (a0 < cp[0U])
      {
        K___uint64_t_int64_t lit;
        lit.fst = (uint64_t)0x8000000000000000U | a0 >> (uint32_t)1U;
        lit.snd = cx + (int64_t)1;
        scrut = lit;
      }
      else
      {
        K___uint64_t_int64_t lit;
        lit.fst = a0;
        lit.snd = cx;
        scrut = lit;
      }
      {
        uint64_t a01 = scrut.fst;
        int64_t bx1 = scrut.snd;
        uint64_t rb = a01 & (uint64_t)1U << (uint32_t)(sh - (int64_t)1);
        uint64_t sb = (a01 & mask) ^ rb;
        ap[0U] = a01 & ~mask;
        st = MPFR_Add1sp1_mk_state(sh, bx1, rb, sb);
      }
    }
    else if (d < MPFR_Lib_gmp_NUMB_BITS)
    {
      uint64_t sb = bp[0U] << (uint32_t)(MPFR_Lib_gmp_NUMB_BITS - d);
      uint64_t a0 = cp[0U] + (bp[0U] >> (uint32_t)d);
      K___uint64_t_uint64_t_int64_t scrut;
      if (a0 < cp[0U])
      {
        K___uint64_t_uint64_t_int64_t lit;
        lit.fst = sb | (a0 & (uint64_t)1U);
        lit.snd = (uint64_t)0x8000000000000000U | a0 >> (uint32_t)1U;
        lit.thd = cx + (int64_t)1;
        scrut = lit;
      }
      else
      {
        K___uint64_t_uint64_t_int64_t lit;
        lit.fst = sb;
        lit.snd = a0;
        lit.thd = cx;
        scrut = lit;
      }
      {
        uint64_t sb1 = scrut.fst;
        uint64_t a01 = scrut.snd;
        int64_t bx1 = scrut.thd;
        uint64_t rb = a01 & (uint64_t)1U << (uint32_t)(sh - (int64_t)1);
        uint64_t sb2 = sb1 | ((a01 & mask) ^ rb);
        ap[0U] = a01 & ~mask;
        st = MPFR_Add1sp1_mk_state(sh, bx1, rb, sb2);
      }
    }
    else
    {
      ap[0U] = cp[0U];
      {
        uint64_t rb = (uint64_t)0U;
        uint64_t sb = (uint64_t)1U;
        st = MPFR_Add1sp1_mk_state(sh, cx, rb, sb);
      }
    }
  }
  if (st.bx > MPFR_Lib_mpfr_EMAX)
  {
    int32_t t = MPFR_Exceptions_mpfr_overflow(a, rnd_mode, a->mpfr_sign);
    return t;
  }
  else
  {
    uint64_t a0 = ap[0U];
    MPFR_Lib_mpfr_SET_EXP(a, st.bx);
    if (st.rb == (uint64_t)0U && st.sb == (uint64_t)0U)
    {
      return MPFR_Lib_mpfr_RET((int32_t)0);
    }
    else if (MPFR_RoundingMode_uu___is_MPFR_RNDN(rnd_mode))
    {
      if
      (
        st.rb
        == (uint64_t)0U
        || (st.sb == (uint64_t)0U && (a0 & (uint64_t)1U << (uint32_t)st.sh) == (uint64_t)0U)
      )
      {
        return MPFR_Lib_mpfr_RET(MPFR_Lib_mpfr_NEG_SIGN(a->mpfr_sign));
      }
      else if (ap[0U] + ((uint64_t)1U << (uint32_t)st.sh) == (uint64_t)0U)
      {
        ap[0U] = ap[0U] + ((uint64_t)1U << (uint32_t)st.sh);
        ap[0U] = (uint64_t)0x8000000000000000U;
        if (st.bx + (int64_t)1 <= MPFR_Lib_mpfr_EMAX)
        {
          MPFR_Lib_mpfr_SET_EXP(a, st.bx + (int64_t)1);
          return MPFR_Lib_mpfr_RET(a->mpfr_sign);
        }
        else
        {
          int32_t t = MPFR_Exceptions_mpfr_overflow(a, rnd_mode, a->mpfr_sign);
          return MPFR_Lib_mpfr_RET(t);
        }
      }
      else
      {
        ap[0U] = ap[0U] + ((uint64_t)1U << (uint32_t)st.sh);
        return MPFR_Lib_mpfr_RET(a->mpfr_sign);
      }
    }
    else if (MPFR_RoundingMode_mpfr_IS_LIKE_RNDZ(rnd_mode, a->mpfr_sign < (int32_t)0))
    {
      return MPFR_Lib_mpfr_RET(MPFR_Lib_mpfr_NEG_SIGN(a->mpfr_sign));
    }
    else if (ap[0U] + ((uint64_t)1U << (uint32_t)st.sh) == (uint64_t)0U)
    {
      ap[0U] = ap[0U] + ((uint64_t)1U << (uint32_t)st.sh);
      ap[0U] = (uint64_t)0x8000000000000000U;
      if (st.bx + (int64_t)1 <= MPFR_Lib_mpfr_EMAX)
      {
        MPFR_Lib_mpfr_SET_EXP(a, st.bx + (int64_t)1);
        return MPFR_Lib_mpfr_RET(a->mpfr_sign);
      }
      else
      {
        int32_t t = MPFR_Exceptions_mpfr_overflow(a, rnd_mode, a->mpfr_sign);
        return MPFR_Lib_mpfr_RET(t);
      }
    }
    else
    {
      ap[0U] = ap[0U] + ((uint64_t)1U << (uint32_t)st.sh);
      return MPFR_Lib_mpfr_RET(a->mpfr_sign);
    }
  }
}

int32_t
(*MPFR_mpfr_add1sp1)(
  MPFR_Lib_mpfr_struct *x0,
  MPFR_Lib_mpfr_struct *x1,
  MPFR_Lib_mpfr_struct *x2,
  MPFR_RoundingMode_mpfr_rnd_t x3,
  int64_t x4
) = MPFR_Add1sp1_mpfr_add1sp1;

int32_t
(*MPFR_mpfr_mul_1)(
  MPFR_Lib_mpfr_struct *x0,
  MPFR_Lib_mpfr_struct *x1,
  MPFR_Lib_mpfr_struct *x2,
  MPFR_RoundingMode_mpfr_rnd_t x3,
  int64_t x4
) = MPFR_Mul_1_mpfr_mul_1;

