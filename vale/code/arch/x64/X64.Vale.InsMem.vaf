include "X64.Vale.InsBasic.vaf"
include{:fstar}{:open} "Types_s"
include{:fstar}{:open} "Arch.Types"
include{:fstar}{:open} "X64.Machine_s"
include{:fstar}{:open} "X64.Memory"
include{:fstar}{:open} "X64.Stack_i"
include{:fstar}{:open} "X64.Memory_Sems"
include{:fstar}{:open} "X64.Stack_Sems"
include{:fstar}{:open} "X64.Vale.State"
include{:fstar}{:open} "X64.Vale.Decls"
include{:fstar}{:open} "X64.Vale.QuickCode"

module X64.Vale.InsMem

#verbatim{:interface}
open Types_s
open X64.Machine_s
open X64.Memory
open X64.Stack_i
open X64.Vale.State
open X64.Vale.Decls
open X64.Vale.QuickCode
open X64.Vale.InsBasic
#endverbatim

#verbatim
open X64.Vale
open X64.Vale.StateLemmas
open X64.Vale.InsLemmas
module I = X64.Instructions_s
module S = X64.Bytes_Semantics_s
module P = X64.Print_s
open X64.Taint_Semantics

friend X64.Vale.StateLemmas
friend X64.Vale.Decls
#endverbatim

//function operator([]) #[a:Type(0), b:Type(0)](m:FStar.Map.t(a, b), key:a):b extern;
//function operator([]) (m:mem, b:X64.Memory.buffer64):fun(int) -> nat64 extern;

#reset-options "--initial_fuel 2 --max_fuel 4 --max_ifuel 2 --z3rlimit 20"

procedure Mem_in(in base:reg64, inline offset:int, ghost b:buffer64, ghost index:int, inline t:taint)
    returns(o:opr)
    {:operand}
    reads
        mem;
    extern;

procedure Load64_buffer(
        out dst:dst_opr64, in src:reg_opr64, inline offset:int, inline t:taint,
        ghost b:buffer64, ghost index:int)
    {:public}
    {:quick exportOnly}
    {:instruction mk_ins(make_instr(I.ins_Mov64, dst, OMem(tuple(MReg(get_reg(src), offset), t))))}
    reads
        mem; memTaint;
    requires
        valid_src_addr(mem, b, index);
        valid_taint_buf64(b, mem, memTaint, t);
        src + offset == buffer_addr(b, mem) + 8 * index;
    ensures
        dst == buffer64_read(b, index, mem);
        //dst == mem[b](index);
        valid_taint_buf64(b, mem, memTaint, t);
{
    low_lemma_valid_mem64(b, #nat(index), mem);
    low_lemma_load_mem64(b, #nat(index), mem);
    lemma_valid_taint64(b, #memTaint_t(memTaint), mem, #nat(index), t);
}

procedure Store64_buffer(
        in dst:reg_opr64, in src:reg_opr64, inline offset:int, inline t:taint,
        ghost b:buffer64, ghost index:int)
    {:public}
    {:quick exportOnly}
    {:instruction mk_ins(make_instr(I.ins_Mov64, OMem(tuple(MReg(get_reg(dst), offset), t)), src))}
    reads memTaint;
    modifies
        mem;
    requires
        valid_dst_addr(mem, b, index);
        valid_taint_buf64(b, mem, memTaint, t);
        dst + offset == buffer_addr(b, mem) + 8 * index;
    ensures
        modifies_mem(loc_buffer(b), old(mem), mem);
        mem == old(buffer64_write(b, index, src, mem));
        valid_taint_buf64(b, mem, memTaint, t);
{
    low_lemma_valid_mem64(b, #nat(index), old(mem));
    low_lemma_store_mem64(b, #nat(index), old(src), old(mem));
    lemma_valid_taint64(b, old(#memTaint_t(memTaint)), old(mem), #nat(index), t);
    same_memTaint64(b, old(mem), mem, old(#memTaint_t(memTaint)), #memTaint_t(memTaint));
}

procedure LoadBe64_buffer(
        out dst:dst_opr64, in src:reg_opr64, inline offset:int, inline t:taint,
        ghost b:buffer64, ghost index:int)
    {:public}
    {:quick exportOnly}
    {:instruction mk_ins(make_instr(I.ins_MovBe64, dst, OMem(tuple(MReg(get_reg(src), offset), t))))}
    reads
        mem; memTaint;
    requires
        valid_src_addr(mem, b, index);
        valid_taint_buf64(b, mem, memTaint, t);
        src + offset == buffer_addr(b, mem) + 8 * index;
    ensures
        dst == reverse_bytes_nat64(buffer64_read(b, index, mem));
        //dst == mem[b](index);
        valid_taint_buf64(b, mem, memTaint, t);
{
    low_lemma_valid_mem64(b, #nat(index), mem);
    low_lemma_load_mem64(b, #nat(index), mem);
    lemma_valid_taint64(b, #memTaint_t(memTaint), mem, #nat(index), t);
}

procedure StoreBe64_buffer(
        in dst:reg_opr64, in src:reg_opr64, inline offset:int, inline t:taint,
        ghost b:buffer64, ghost index:int)
    {:public}
    {:quick exportOnly}
    {:instruction mk_ins(make_instr(I.ins_MovBe64, OMem(tuple(MReg(get_reg(dst), offset), t)), src))}
    reads memTaint;
    modifies
        mem;
    requires
        valid_dst_addr(mem, b, index);
        valid_taint_buf64(b, mem, memTaint, t);
        dst + offset == buffer_addr(b, mem) + 8 * index;
    ensures
        modifies_mem(loc_buffer(b), old(mem), mem);
        mem == old(buffer64_write(b, index, reverse_bytes_nat64(src), mem));
        valid_taint_buf64(b, mem, memTaint, t);
{
    low_lemma_valid_mem64(b, #nat(index), old(mem));
    low_lemma_store_mem64(b, #nat(index), old(reverse_bytes_nat64(src)), old(mem));
    lemma_valid_taint64(b, old(#memTaint_t(memTaint)), old(mem), #nat(index), t);
    same_memTaint64(b, old(mem), mem, old(#memTaint_t(memTaint)), #memTaint_t(memTaint));
}

