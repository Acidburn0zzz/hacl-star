include "Vale.X64.InsBasic.vaf"
include{:fstar}{:open} "Vale.Def.Types_s"
include{:fstar}{:open} "Vale.Arch.Types"
include{:fstar}{:open} "Vale.Arch.HeapTypes_s"
include{:fstar}{:open} "Vale.Arch.HeapImpl"
include{:fstar}{:open} "Vale.X64.Machine_s"
include{:fstar}{:open} "Vale.X64.Memory"
include{:fstar}{:open} "Vale.X64.Stack_i"
include{:fstar}{:open} "Vale.X64.Memory_Sems"
include{:fstar}{:open} "Vale.X64.Stack_Sems"
include{:fstar}{:open} "Vale.X64.State"
include{:fstar}{:open} "Vale.X64.Decls"
include{:fstar}{:open} "Vale.X64.QuickCode"
include{:fstar}{:open} "Vale.X64.CPU_Features_s"
include{:fstar}{:open} "Vale.Lib.Seqs"
include{:/*TODO*/fstar}{:open Seq} "FStar.Seq.Base"

module Vale.X64.InsMem

#verbatim{:interface}
open FStar.Seq
open Vale.Def.Types_s
open Vale.Arch.HeapTypes_s
open Vale.Arch.HeapImpl
open Vale.X64.Machine_s
open Vale.X64.Memory
open Vale.X64.Stack_i
open Vale.X64.State
open Vale.X64.Decls
open Vale.X64.QuickCode
open Vale.X64.InsBasic
open Vale.X64.CPU_Features_s
open Vale.Lib.Seqs
#endverbatim

#verbatim
open Vale.X64
open Vale.X64.StateLemmas
open Vale.X64.InsLemmas
open Vale.Arch.Heap
open Vale.Arch.HeapImpl
module I = Vale.X64.Instructions_s
module S = Vale.X64.Machine_Semantics_s
module P = Vale.X64.Print_s
open Vale.X64.Taint_Semantics

friend Vale.X64.Decls
#endverbatim

//function operator([]) #[a:Type(0), b:Type(0)](m:FStar.Map.t(a, b), key:a):b extern;
//function operator([]) (m:heap0, b:Vale.X64.Memory.buffer64):fun(int) -> nat64 extern;

#reset-options "--initial_fuel 2 --max_fuel 2 --max_ifuel 2 --z3rlimit 20"

procedure Mem_in(in base:reg64, inline offset:int, ghost b:buffer64, ghost index:int, inline t:taint)
    returns(o:opr)
    {:operand}
    reads
        heap0;
    extern;

procedure Mem_lemma(ghost base:va_operand, ghost offset:int, ghost b:buffer64, ghost index:int, ghost t:taint)
    {:public}
    {:quick exportOnly}
    {:typecheck false}
    reads
        mem; heap0; memLayout;
    requires
        base is OReg;
        valid_src_addr(heap0, b, index);
        valid_layout_buffer(b, memLayout, heap0);
        valid_taint_buf64(b, heap0, memLayout.vl_taint, t);
        eval_operand(base, this) + offset == buffer_addr(b, heap0) + 8 * index;
    ensures
        valid_operand(va_opr_code_Mem(base, offset, t), this);
        load_mem64(buffer_addr(b, heap0) + 8 * index, mem) == buffer_read(b, index, heap0);
{
    lemma_opr_Mem(this, base, offset, b, index, t);
}

#verbatim
let create_heaplets_this (bs:Seq.seq buffer_info) (modloc:loc) (s:vale_state) : GTot vale_state =
  {s with vs_heap = Vale.X64.Memory_Sems.create_heaplets bs modloc s.vs_heap}

let destroy_heaplets_this (s:vale_state) : Ghost vale_state
  (requires state_inv s)
  (ensures fun _ -> True)
  =
  {s with vs_heap = Vale.X64.Memory_Sems.destroy_heaplets s.vs_heap}
#endverbatim

#verbatim{:interface}
let heaplet_id_is_none (h:vale_heap) =
  get_heaplet_id h == None

let heaplet_id_is_some (h:vale_heap) (i:heaplet_id) =
  get_heaplet_id h == Some i

unfold let norm_list (p:prop) : prop =
  norm [zeta; iota; delta_only [`%list_to_seq_post]] p

let declare_buffer64 (b:buffer TUInt64) (hid:heaplet_id) (t:taint) (mut:mutability) =
  Mkbuffer_info TUInt64 b hid t mut

let create_post (layout:vale_heap_layout) (bs:Seq.seq buffer_info) =
  forall (i:nat).{:pattern Seq.index bs i} i < Seq.length bs ==> (
    let Mkbuffer_info t b hid _ _ = Seq.index bs i in
    valid_layout_buffer_id t b layout (Some hid))
#endverbatim

function create_heaplets_this(buffers:Seq.seq(buffer_info), modloc:loc, s:vale_state):vale_state extern;
function destroy_heaplets_this(s:vale_state):vale_state extern;
function heaplet_id_is_none(h:vale_heap):prop extern;
function heaplet_id_is_some(h:vale_heap, heaplet_id:int):prop extern;
function norm_list(p:prop):prop extern;
function declare_buffer64(b:buffer64, hid:heaplet_id, t:taint, mut:mutability):buffer_info extern;
function create_post(layout:vale_heap_layout, bs:Seq.seq(buffer_info)):prop extern;
ghost procedure Vale.X64.StateLemmas.use_machine_state_equal() extern;

// TODO: this is used for the current (trivial) mem_inv; it will probably be removed for the real mem_inv
procedure CreateNoHeaplets()
    {:public}
    {:quick exportOnly}
    {:instruction mk_ins(make_instr_annotate(I.ins_Ghost, S.AnnotateGhost()))}
    reads
        mem;
    ensures
        heaplet_id_is_none(mem);
{
    let dummy := destroy_heaplets_this(this);
}

procedure CreateHeaplets(ghost buffers:list(buffer_info))
    {:public}
    {:quick exportOnly}
    {:instruction mk_ins(make_instr_annotate(I.ins_Ghost, S.AnnotateGhost()))}
    lets
        bs := list_to_seq(buffers);
    reads
        mem; heap0;
    modifies
        memLayout;
    requires
        is_initial_heap(memLayout, mem);
        norm_list(list_to_seq_post(buffers, bs, 0)) ==> init_heaplets_req(mem, bs);
    ensures
        norm_list(list_to_seq_post(buffers, bs, 0));
        create_post(memLayout, bs);
        memLayout.vl_taint == old(memLayout.vl_taint);
        heaplet_id_is_none(mem);
        heaplet_id_is_some(heap0, 0);
{
    let modloc := loc_none;
    lemma_list_to_seq(buffers);
    this := create_heaplets_this(bs, modloc, this);
    lemma_create_heaplets(bs, modloc, old(this).vs_heap);
    Vale.X64.StateLemmas.use_machine_state_equal();
}

procedure DestroyHeaplets()
    {:public}
    {:quick exportOnly}
    {:instruction mk_ins(make_instr_annotate(I.ins_Ghost, S.AnnotateGhost()))}
    reads
        mem; heap0;
    modifies
        memLayout;
    ensures
        memLayout.vl_taint == old(memLayout.vl_taint);
        heaplet_id_is_none(mem);
        vale_heap_data_eq(mem, heap0);
{
    reveal_mem_inv();
    this := destroy_heaplets_this(this);
    Vale.X64.StateLemmas.use_machine_state_equal();
}

procedure Load64_buffer(
        out dst:dst_opr64, in src:reg_opr64, inline offset:int, inline t:taint,
        ghost b:buffer64, ghost index:int)
    {:public}
    {:quick exportOnly}
    {:instruction mk_ins(make_instr(I.ins_Mov64, dst, OMem(tuple(MReg(get_reg(src), offset), t))))}
    reads
        heap0; memLayout;
    requires
        valid_src_addr(heap0, b, index);
        valid_layout_buffer(b, memLayout, heap0);
        valid_taint_buf64(b, heap0, memLayout.vl_taint, t);
        src + offset == buffer_addr(b, heap0) + 8 * index;
    ensures
        dst == buffer64_read(b, index, heap0);
{
    low_lemma_load_mem64_full(b, #nat(index), this.vs_heap, t);
}

procedure Store64_buffer(
        in dst:reg_opr64, in src:reg_opr64, inline offset:int, inline t:taint,
        ghost b:buffer64, ghost index:int)
    {:public}
    {:quick exportOnly}
    {:instruction mk_ins(make_instr(I.ins_Mov64, OMem(tuple(MReg(get_reg(dst), offset), t)), src))}
    reads
        memLayout;
    modifies
        heap0;
    requires
        valid_dst_addr(heap0, b, index);
        valid_layout_buffer(b, memLayout, heap0);
        valid_taint_buf64(b, heap0, memLayout.vl_taint, t);
        dst + offset == buffer_addr(b, heap0) + 8 * index;
    ensures
        modifies_mem(loc_buffer(b), old(heap0), heap0);
        heap0 == old(buffer64_write(b, index, src, heap0));
        valid_taint_buf64(b, heap0, memLayout.vl_taint, t);
{
    low_lemma_store_mem64_full(b, #nat(index), old(src), old(this).vs_heap, t);
}

procedure LoadBe64_buffer(
        out dst:dst_opr64, in src:reg_opr64, inline offset:int, inline t:taint,
        ghost b:buffer64, ghost index:int)
    {:public}
    {:quick exportOnly}
    {:instruction mk_ins(make_instr(I.ins_MovBe64, dst, OMem(tuple(MReg(get_reg(src), offset), t))))}
    reads
        heap0; memLayout;
    requires
        movbe_enabled;
        valid_src_addr(heap0, b, index);
        valid_layout_buffer(b, memLayout, heap0);
        valid_taint_buf64(b, heap0, memLayout.vl_taint, t);
        src + offset == buffer_addr(b, heap0) + 8 * index;
    ensures
        dst == reverse_bytes_nat64(buffer64_read(b, index, heap0));
{
    low_lemma_load_mem64_full(b, #nat(index), this.vs_heap, t);
}

procedure StoreBe64_buffer(
        in dst:reg_opr64, in src:reg_opr64, inline offset:int, inline t:taint,
        ghost b:buffer64, ghost index:int)
    {:public}
    {:quick exportOnly}
    {:instruction mk_ins(make_instr(I.ins_MovBe64, OMem(tuple(MReg(get_reg(dst), offset), t)), src))}
    reads
        memLayout;
    modifies
        heap0;
    requires
        movbe_enabled;
        valid_dst_addr(heap0, b, index);
        valid_layout_buffer(b, memLayout, heap0);
        valid_taint_buf64(b, heap0, memLayout.vl_taint, t);
        dst + offset == buffer_addr(b, heap0) + 8 * index;
    ensures
        modifies_mem(loc_buffer(b), old(heap0), heap0);
        heap0 == old(buffer64_write(b, index, reverse_bytes_nat64(src), heap0));
        valid_taint_buf64(b, heap0, memLayout.vl_taint, t);
{
    low_lemma_store_mem64_full(b, #nat(index), old(reverse_bytes_nat64(src)), old(this).vs_heap, t);
}

