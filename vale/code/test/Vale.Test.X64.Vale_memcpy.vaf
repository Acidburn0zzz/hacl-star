include "../arch/x64/Vale.X64.InsBasic.vaf"
include "../arch/x64/Vale.X64.InsMem.vaf"
include "../arch/x64/Vale.X64.InsVector.vaf"

module Vale.Test.X64.Vale_memcpy
#verbatim{:interface}{:implementation}

open Vale.X64.Machine_s
open Vale.X64.Memory
open Vale.X64.State
open Vale.X64.Decls
open Vale.X64.InsBasic
open Vale.X64.InsMem
open Vale.X64.InsVector
open Vale.X64.QuickCode
open Vale.X64.QuickCodes
#set-options "--z3rlimit 20"
#endverbatim

procedure Memcpy(inline win:bool, ghost dst:buffer64, ghost src:buffer64)
    {:public}
    {:exportSpecs}
    requires
        locs_disjoint(list(loc_buffer(dst), loc_buffer(src)));
        buffer_readable(mem, dst);
        buffer_readable(mem, src);
        buffer_writeable(dst);
        valid_taint_buf64(dst, mem, memTaint, Secret);
        valid_taint_buf64(src, mem, memTaint, Secret);
        buffer_length(src) == 2;
        buffer_length(dst) == 2;
        win ==> rcx == buffer_addr(dst, mem);
        win ==> rdx == buffer_addr(src, mem);
        !win ==> rdi == buffer_addr(dst, mem);
        !win ==> rsi == buffer_addr(src, mem);
    ensures
        rsp == old(rsp);

        win ==>  rbx == old(rbx);
        win ==>  rbp == old(rbp);
        win ==>  rdi == old(rdi);
        win ==>  rsi == old(rsi);
        win ==>  rsp == old(rsp);
        win ==>  r12 == old(r12);
        win ==>  r13 == old(r13);
        win ==>  r14 == old(r14);
        win ==>  r15 == old(r15);
        !win ==>  rbx == old(rbx);
        !win ==>  rbp == old(rbp);
        !win ==>  r12 == old(r12);
        !win ==>  r13 == old(r13);
        !win ==>  r14 == old(r14);
        !win ==>  r15 == old(r15);
        win ==>  xmm6 == old(xmm6);
        win ==>  xmm7 == old(xmm7);
        win ==>  xmm8 == old(xmm8);
        win ==>  xmm9 == old(xmm9);
        win ==>  xmm10 == old(xmm10);
        win ==>  xmm11 == old(xmm11);
        win ==>  xmm12 == old(xmm12);
        win ==>  xmm13 == old(xmm13);
        win ==>  xmm14 == old(xmm14);
        win ==>  xmm15 == old(xmm15);

        buffer_as_seq(mem, dst) == buffer_as_seq(mem, src);
//        forall(i) 0 <= i && i < 2 ==> buffer64_read(dst, i, mem) == buffer64_read(src, i, mem);
        modifies_mem(loc_buffer(dst), old(mem), mem);
    reads memTaint;
    modifies
        rax; rbx; rcx; rdx; rsi; rdi; rbp; rsp; r8; r9; r10; r11; r12; r13; r14; r15;
        xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15;
        efl; mem;
{
    inline if (win)
    {
        Load64_buffer(rax, rdx, 0, Secret, src, 0);
        Load64_buffer(r9, rdx, 8, Secret, src, 1);
        Store64_buffer(rcx, rax, 0, Secret, dst, 0);
        Store64_buffer(rcx, r9, 8, Secret, dst, 1);
    }
    else
    {
        Load64_buffer(rax, rsi, 0, Secret, src, 0);
        Load64_buffer(rcx, rsi, 8, Secret, src, 1);
        Store64_buffer(rdi, rax, 0, Secret, dst, 0);
        Store64_buffer(rdi, rcx, 8, Secret, dst, 1);
    }
    assert(Seq.equal(buffer_as_seq(mem, dst), buffer_as_seq(mem, src)));
}

/*
Benchmarking experiments to see impact of heap representation on verification time
*/

procedure Load64_fake(out dst:dst_opr64, in src:reg_opr64, ghost b:Seq.seq(nat64), ghost index:nat)
    {:public}
    {:quick exportOnly}
    requires
        0 <= index < Seq.length(b);
    ensures
        dst == Seq.index(b, index);
{
    assume false;
}

procedure Store64_fake(in dst:reg_opr64, in src:reg_opr64, ghost b_in:Seq.seq(nat64), ghost index:nat)
    returns(ghost b:Seq.seq(nat64))
    {:public}
    {:quick exportOnly}
    requires
        0 <= index < Seq.length(b_in);
    ensures
        b == Seq.upd(b_in, index, src);
{
    b := Seq.upd(b_in, index, src);
}

procedure Benchmark_fake_memcpy(inline win:bool, ghost dst_in:Seq.seq(nat64), ghost src_in:Seq.seq(nat64))
    returns(ghost dst:Seq.seq(nat64), ghost src:Seq.seq(nat64))
    {:quick}
    requires
        Seq.length(src_in) == 2;
        Seq.length(dst_in) == 2;
    ensures
        rsp == old(rsp);

        win ==>  rbx == old(rbx);
        win ==>  rbp == old(rbp);
        win ==>  rdi == old(rdi);
        win ==>  rsi == old(rsi);
        win ==>  rsp == old(rsp);
        win ==>  r12 == old(r12);
        win ==>  r13 == old(r13);
        win ==>  r14 == old(r14);
        win ==>  r15 == old(r15);
        !win ==>  rbx == old(rbx);
        !win ==>  rbp == old(rbp);
        !win ==>  r12 == old(r12);
        !win ==>  r13 == old(r13);
        !win ==>  r14 == old(r14);
        !win ==>  r15 == old(r15);
        win ==>  xmm6 == old(xmm6);
        win ==>  xmm7 == old(xmm7);
        win ==>  xmm8 == old(xmm8);
        win ==>  xmm9 == old(xmm9);
        win ==>  xmm10 == old(xmm10);
        win ==>  xmm11 == old(xmm11);
        win ==>  xmm12 == old(xmm12);
        win ==>  xmm13 == old(xmm13);
        win ==>  xmm14 == old(xmm14);
        win ==>  xmm15 == old(xmm15);

        Seq.length(src) == 2;
        Seq.length(dst) == 2;
        dst == src;
    modifies
        rax; rbx; rcx; rdx; rsi; rdi; rbp; rsp; r8; r9; r10; r11; r12; r13; r14; r15;
        xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15;
        efl;
{
    src := src_in;
    dst := dst_in;
    inline if (win)
    {
        Load64_fake(rax, rdx, src, 0);
        Load64_fake(r9, rdx, src, 1);
        dst := Store64_fake(rcx, rax, dst, 0);
        dst := Store64_fake(rcx, r9, dst, 1);
    }
    else
    {
        Load64_fake(rax, rsi, src, 0);
        Load64_fake(rcx, rsi, src, 1);
        dst := Store64_fake(rdi, rax, dst, 0);
        dst := Store64_fake(rdi, rcx, dst, 1);
    }
    assert(Seq.equal(dst, src));
}

// procedure Load128_buffer
procedure Load128_fake(
        out dst:xmm, in src:reg_opr64, ghost b:Seq.seq(quad32), ghost index:nat)
    {:public}
    requires
        0 <= index < Seq.length(b);
    ensures
        dst == Seq.index(b, index);
{
    assume false;
}

// procedure Store128_buffer
procedure Store128_fake(
        in dst:reg_opr64, in src:xmm, ghost b_in:Seq.seq(quad32), ghost index:nat)
    returns(ghost b:Seq.seq(quad32))
    {:public}
    requires
        0 <= index < Seq.length(b_in);
    ensures
        b == Seq.upd(b_in, index, src);
{
    b := Seq.upd(b_in, index, src);
}

// procedure LoadBe64_buffer128
procedure LoadBe64_fake128(
        out dst:reg_opr64, in src:reg_opr64, inline upper:bool,
        ghost b:Seq.seq(quad32), ghost index:nat)
    {:public}
    requires
        0 <= index < Seq.length(b);
    ensures
        dst == reverse_bytes_nat64(if upper then hi64(Seq.index(b, index)) else lo64(Seq.index(b, index)));
{
    assume false;
}

procedure Store64_fake128(
        in dst:reg_opr64, in src:reg_opr64, inline upper:bool,
        ghost b_in:Seq.seq(quad32), ghost index:nat)
    returns(ghost b:Seq.seq(quad32))
    {:public}
    requires
        0 <= index < Seq.length(b_in);
    ensures
        b == old(Seq.upd(b_in, index, insert_nat64_opaque(old(Seq.index(b_in, index)), src, if upper then 1 else 0)));
{
    b := old(Seq.upd(b_in, index, insert_nat64_opaque(old(Seq.index(b_in, index)), src, if upper then 1 else 0)));
}

///
///
///

procedure hLoad64_buffer(
        out dst:dst_opr64, in hp:heap, in src:reg_opr64, inline offset:int, inline t:taint,
        ghost b:buffer64, ghost index:int)
    {:public}
    //{:instruction mk_ins(make_instr(I.ins_Mov64, dst, OMem(tuple(MReg(get_reg(src), offset), t))))}
    requires
        src + offset == buffer_addr(b, hp) + 8 * index;
    ensures
        dst == buffer64_read(b, index, hp);
{
    assume false;
}

procedure hStore64_buffer(
        in dst:reg_opr64, in hp:heap, in src:reg_opr64, inline offset:int, inline t:taint,
        ghost b:buffer64, ghost index:int)
    {:public}
    //{:instruction mk_ins(make_instr(I.ins_Mov64, OMem(tuple(MReg(get_reg(dst), offset), t)), src))}
    requires
        dst + offset == buffer_addr(b, hp) + 8 * index;
    ensures
        modifies_mem(loc_buffer(b), old(hp), hp);
        hp == old(buffer64_write(b, index, src, hp));
{
    assume false;
}

procedure hLoadBe64_buffer(
        out dst:dst_opr64, in hp:heap, in src:reg_opr64, inline offset:int, inline t:taint,
        ghost b:buffer64, ghost index:int)
    {:public}
    //{:instruction mk_ins(make_instr(I.ins_MovBe64, dst, OMem(tuple(MReg(get_reg(src), offset), t))))}
    requires
        src + offset == buffer_addr(b, hp) + 8 * index;
    ensures
        dst == reverse_bytes_nat64(buffer64_read(b, index, hp));
{
    assume false;
}

procedure hStoreBe64_buffer(
        in dst:reg_opr64, in hp:heap, in src:reg_opr64, inline offset:int, inline t:taint,
        ghost b:buffer64, ghost index:int)
    {:public}
    //{:instruction mk_ins(make_instr(I.ins_MovBe64, OMem(tuple(MReg(get_reg(dst), offset), t)), src))}
    requires
        dst + offset == buffer_addr(b, hp) + 8 * index;
    ensures
        modifies_mem(loc_buffer(b), old(hp), hp);
        hp == old(buffer64_write(b, index, reverse_bytes_nat64(src), hp));
{
    assume false;
}

procedure Memcpy_1heap(inline win:bool, ghost dst:buffer64, ghost src:buffer64)
    {:public}
    {:exportSpecs}
    requires
        locs_disjoint(list(loc_buffer(dst), loc_buffer(src)));
        buffer_readable(heap1, dst);
        buffer_readable(heap1, src);
        buffer_writeable(dst);
        buffer_length(src) == 2;
        buffer_length(dst) == 2;
        win ==> rcx == buffer_addr(dst, heap1);
        win ==> rdx == buffer_addr(src, heap1);
        !win ==> rdi == buffer_addr(dst, heap1);
        !win ==> rsi == buffer_addr(src, heap1);
    ensures
        rsp == old(rsp);

        win ==>  rbx == old(rbx);
        win ==>  rbp == old(rbp);
        win ==>  rdi == old(rdi);
        win ==>  rsi == old(rsi);
        win ==>  rsp == old(rsp);
        win ==>  r12 == old(r12);
        win ==>  r13 == old(r13);
        win ==>  r14 == old(r14);
        win ==>  r15 == old(r15);
        !win ==>  rbx == old(rbx);
        !win ==>  rbp == old(rbp);
        !win ==>  r12 == old(r12);
        !win ==>  r13 == old(r13);
        !win ==>  r14 == old(r14);
        !win ==>  r15 == old(r15);
        win ==>  xmm6 == old(xmm6);
        win ==>  xmm7 == old(xmm7);
        win ==>  xmm8 == old(xmm8);
        win ==>  xmm9 == old(xmm9);
        win ==>  xmm10 == old(xmm10);
        win ==>  xmm11 == old(xmm11);
        win ==>  xmm12 == old(xmm12);
        win ==>  xmm13 == old(xmm13);
        win ==>  xmm14 == old(xmm14);
        win ==>  xmm15 == old(xmm15);

        buffer_as_seq(heap1, dst) == buffer_as_seq(heap1, src);
//        forall(i) 0 <= i && i < 2 ==> buffer64_read(dst, i, mem) == buffer64_read(src, i, mem);
        modifies_mem(loc_buffer(dst), old(heap1), heap1);
    modifies
        rax; rbx; rcx; rdx; rsi; rdi; rbp; rsp; r8; r9; r10; r11; r12; r13; r14; r15;
        xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15;
        efl; heap1;
{
    inline if (win)
    {
        hLoad64_buffer(rax, heap1, rdx, 0, Secret, src, 0);
        hLoad64_buffer(r9, heap1, rdx, 8, Secret, src, 1);
        hStore64_buffer(rcx, heap1, rax, 0, Secret, dst, 0);
        hStore64_buffer(rcx, heap1, r9, 8, Secret, dst, 1);
    }
    else
    {
        hLoad64_buffer(rax, heap1, rsi, 0, Secret, src, 0);
        hLoad64_buffer(rcx, heap1, rsi, 8, Secret, src, 1);
        hStore64_buffer(rdi, heap1, rax, 0, Secret, dst, 0);
        hStore64_buffer(rdi, heap1, rcx, 8, Secret, dst, 1);
    }
    assert(Seq.equal(buffer_as_seq(heap1, dst), buffer_as_seq(heap1, src)));
}
    
procedure Memcpy_2heap(inline win:bool, ghost dst:buffer64, ghost src:buffer64)
    {:public}
    {:exportSpecs}
    requires
        locs_disjoint(list(loc_buffer(dst), loc_buffer(src)));
        buffer_readable(heap1, dst);
        buffer_readable(heap2, src);
        buffer_writeable(dst);
        buffer_length(src) == 2;
        buffer_length(dst) == 2;
        win ==> rcx == buffer_addr(dst, heap1);
        win ==> rdx == buffer_addr(src, heap2);
        !win ==> rdi == buffer_addr(dst, heap1);
        !win ==> rsi == buffer_addr(src, heap2);
    ensures
        rsp == old(rsp);

        win ==>  rbx == old(rbx);
        win ==>  rbp == old(rbp);
        win ==>  rdi == old(rdi);
        win ==>  rsi == old(rsi);
        win ==>  rsp == old(rsp);
        win ==>  r12 == old(r12);
        win ==>  r13 == old(r13);
        win ==>  r14 == old(r14);
        win ==>  r15 == old(r15);
        !win ==>  rbx == old(rbx);
        !win ==>  rbp == old(rbp);
        !win ==>  r12 == old(r12);
        !win ==>  r13 == old(r13);
        !win ==>  r14 == old(r14);
        !win ==>  r15 == old(r15);
        win ==>  xmm6 == old(xmm6);
        win ==>  xmm7 == old(xmm7);
        win ==>  xmm8 == old(xmm8);
        win ==>  xmm9 == old(xmm9);
        win ==>  xmm10 == old(xmm10);
        win ==>  xmm11 == old(xmm11);
        win ==>  xmm12 == old(xmm12);
        win ==>  xmm13 == old(xmm13);
        win ==>  xmm14 == old(xmm14);
        win ==>  xmm15 == old(xmm15);

        buffer_as_seq(heap1, dst) == buffer_as_seq(heap2, src);
//        forall(i) 0 <= i && i < 2 ==> buffer64_read(dst, i, mem) == buffer64_read(src, i, mem);
        modifies_mem(loc_buffer(dst), old(heap1), heap1);
    modifies
        rax; rbx; rcx; rdx; rsi; rdi; rbp; rsp; r8; r9; r10; r11; r12; r13; r14; r15;
        xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15;
        efl; heap1; heap2;
{
    inline if (win)
    {
        hLoad64_buffer(rax, heap2, rdx, 0, Secret, src, 0);
        hLoad64_buffer(r9, heap2, rdx, 8, Secret, src, 1);
        hStore64_buffer(rcx, heap1, rax, 0, Secret, dst, 0);
        hStore64_buffer(rcx, heap1, r9, 8, Secret, dst, 1);
    }
    else
    {
        hLoad64_buffer(rax, heap2, rsi, 0, Secret, src, 0);
        hLoad64_buffer(rcx, heap2, rsi, 8, Secret, src, 1);
        hStore64_buffer(rdi, heap1, rax, 0, Secret, dst, 0);
        hStore64_buffer(rdi, heap1, rcx, 8, Secret, dst, 1);
    }
    assert(Seq.equal(buffer_as_seq(heap1, dst), buffer_as_seq(heap2, src)));
}
