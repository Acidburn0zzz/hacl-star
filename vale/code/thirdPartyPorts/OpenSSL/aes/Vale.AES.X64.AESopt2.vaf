include "../../../arch/x64/Vale.X64.InsBasic.vaf"
include "../../../arch/x64/Vale.X64.InsMem.vaf"
include "../../../arch/x64/Vale.X64.InsVector.vaf"
include "../../../arch/x64/Vale.X64.InsAes.vaf"
include "../../../crypto/aes/x64/Vale.AES.X64.PolyOps.vaf"
include{:fstar}{:open} "Vale.Def.Prop_s"
include{:fstar}{:open} "Vale.Def.Opaque_s"
include{:fstar}{:open} "Vale.Def.Words_s"
include{:fstar}{:open} "Vale.Def.Types_s"
include{:/*TODO*/fstar}{:open} "FStar.Seq.Base"
include{:fstar}{:open} "Vale.AES.AES_s"
include{:fstar}{:open} "Vale.X64.Machine_s"
include{:fstar}{:open} "Vale.X64.Memory"
include{:fstar}{:open} "Vale.X64.State"
include{:fstar}{:open} "Vale.X64.Decls"
include{:fstar}{:open} "Vale.X64.QuickCode"
include{:fstar}{:open} "Vale.X64.QuickCodes"
include{:fstar}{:open} "Vale.Arch.Types"
include{:fstar}{:open} "Vale.AES.AES_helpers"
include{:fstar}{:open} "Vale.Poly1305.Math"
include{:fstar}{:open} "Vale.AES.GCM_helpers"
include{:fstar}{:open} "Vale.AES.GCTR_s"
include{:fstar}{:open} "Vale.AES.GCTR"
include{:fstar}{:open} "Vale.Arch.TypesNative"
include{:fstar}{:open} "Vale.X64.CPU_Features_s"

include{:fstar}{:open} "Vale.Math.Poly2_s"
include{:fstar}{:open} "Vale.Math.Poly2"
include{:fstar}{:open} "Vale.Math.Poly2.Bits_s"
include{:fstar}{:open} "Vale.Math.Poly2.Bits"
include{:fstar}{:open} "Vale.Math.Poly2.Words"
include{:fstar}{:open} "Vale.Math.Poly2.Lemmas"
include{:fstar}{:open} "Vale.AES.GF128_s"
include{:fstar}{:open} "Vale.AES.GF128"
include{:fstar}{:open} "Vale.AES.GHash"
module Vale.AES.X64.AESopt2

#verbatim{:interface}{:implementation}
open Vale.Def.Prop_s
open Vale.Def.Opaque_s
open Vale.Def.Words_s
open Vale.Def.Types_s
open FStar.Seq
open Vale.AES.AES_s
open Vale.X64.Machine_s
open Vale.X64.Memory
open Vale.X64.State
open Vale.X64.Decls
open Vale.X64.InsBasic
open Vale.X64.InsMem
open Vale.X64.InsVector
open Vale.X64.InsAes
open Vale.X64.QuickCode
open Vale.X64.QuickCodes
open Vale.Arch.Types
open Vale.AES.AES_helpers
open Vale.Poly1305.Math    // For lemma_poly_bits64()
open Vale.AES.GCM_helpers
open Vale.AES.GCTR_s
open Vale.AES.GCTR
open Vale.Arch.TypesNative
open Vale.X64.CPU_Features_s
open Vale.AES.X64.PolyOps

open Vale.Math.Poly2_s
open Vale.Math.Poly2
open Vale.Math.Poly2.Bits_s
open Vale.Math.Poly2.Bits
open Vale.Math.Poly2.Lemmas
open Vale.AES.GF128_s
open Vale.AES.GF128
open Vale.AES.GHash
#endverbatim

#token +. precedence +
#token *. precedence *
#token %. precedence *
#token ~~ precedence !
function operator(+.) (a:poly, b:poly):poly := add;
function operator(*.) (a:poly, b:poly):poly := mul;
function operator(%.) (a:poly, b:poly):poly := mod;
function operator(~~) (a:quad32):poly := of_quad32;
function operator([]) #[a:Type(0)](s:FStar.Seq.Base.seq(a), i:int):a extern;

#verbatim{:interface}

unfold let va_subscript_FStar__Seq__Base__seq = Seq.index

let hkeys_b_powers (hkeys_b:buffer128) (mem:vale_heap) (memTaint:memtaint) (ptr:int) (h:poly) =
  validSrcAddrs128 mem ptr hkeys_b 8 memTaint Secret /\
  of_quad32 (buffer128_read hkeys_b 0 mem) == gf128_power h 1 /\
  of_quad32 (buffer128_read hkeys_b 1 mem) == gf128_power h 2 /\
  of_quad32 (buffer128_read hkeys_b 3 mem) == gf128_power h 3 /\
  of_quad32 (buffer128_read hkeys_b 4 mem) == gf128_power h 4 /\
  of_quad32 (buffer128_read hkeys_b 6 mem) == gf128_power h 5 /\
  of_quad32 (buffer128_read hkeys_b 7 mem) == gf128_power h 6

let quad32_opt_rev (b:bool) (q:quad32) : quad32 =
  if b then reverse_bytes_quad32 q else q

let index_opt_rev (b:bool) (len n i:int) : int =
  if b then len - 1 - i else len - n + i

let scratch_b_data
    (rev_bytes:bool) (rev_blocks:bool) (scratch_b:buffer128) (scratch_len count:int) (mem:vale_heap)
    (memTaint:memtaint) (ptr:int) (data:seq quad32)
  =
  validSrcAddrs128 mem ptr scratch_b scratch_len memTaint Secret /\
  (forall (i:nat).{:pattern (index data i)}
    i < count /\ i < length data ==>
      buffer128_read scratch_b (index_opt_rev rev_blocks scratch_len (length data) i) mem ==
      quad32_opt_rev rev_bytes (index data i))
#endverbatim

function hkeys_b_powers(hkeys_b:buffer128, mem:vale_heap, memTaint:memtaint, ptr:int, h:poly):prop extern;
function index_opt_rev(b:bool, len:int, n:int, i:int):int extern;
function quad32_opt_rev(b:bool, q:quad32):quad32 extern;
function scratch_b_data(rev_bytes:bool, rev_blocks:bool, scratch_b:buffer128, scratch_len:int,
    count:int, mem:vale_heap, memTaint:memtaint, ptr:int, data:seq(quad32)):prop extern;

#reset-options "--z3rlimit 20"

procedure MulAdd_unroll_i(
        inline rev_bytes:bool,
        inline rev_blocks:bool,
        inline is_first:bool,
        inline is_last:bool,
        inline power_index:int,
        ghost scratch_len:nat64,
        ghost n:nat,
        ghost m:int,
        ghost hkeys_b:buffer128,
        ghost scratch_b:buffer128,
        ghost h:poly,
        ghost prev:poly,
        ghost data:seq(quad32))
    {:quick}
    lets
        Xip @= r9; scratch_ptr @= rcx;
        Ii @= xmm0; T1 @= xmm1; T2 @= xmm2; Hkey @= xmm3;
        Z0 @= xmm4; Z1 @= xmm5; Z2 @= xmm6; Z3 @= xmm7;
        Xi @= xmm8; rev_mask @= xmm9;
        pdata := fun_seq_quad32_LE_poly128(data);
        scratch_index := index_opt_rev(rev_blocks, scratch_len, n, n - (m + 2)); // index of m + 1 iteration
    reads
        mem; memTaint; Xip; rbp; Xi; rev_mask;
    modifies
        efl; scratch_ptr; Ii; T1; T2; Hkey; Z0; Z1; Z2; Z3;
    requires
        pclmulqdq_enabled && avx_enabled;
        length(data) >= n;
        0 <= m < n <= scratch_len;
        is_first <==> m == 0;
        is_last <==> m == n - 1;
        buffers_disjoint128(hkeys_b, scratch_b);
        validSrcAddrs128(mem, Xip - 0x20, hkeys_b, 8, memTaint, Secret);
        validSrcAddrs128(mem, rbp, scratch_b, scratch_len, memTaint, Secret);
        rbp + 0x10 * scratch_len <= pow2_64;
        of_quad32(Xi) == prev;
        scratch_ptr == rbp + 0x10 * (scratch_index + (if rev_blocks then (-1) else 1));
        0 <= power_index < 8;
        !is_first ==> of_quad32(Z0) +. shift(of_quad32(Z2), 64) +. shift(of_quad32(Z3), 128) ==
            ghash_unroll_back(h, prev, pdata, 0, n, #nat(m - 1));
        Ii == reverse_bytes_quad32(data[#nat(n - m - 1)]);
        of_quad32(Z1) == gf128_power(h, #nat(m + 1));
        !rev_bytes ==> rev_mask == Mkfour(0x0C0D0E0F, 0x08090A0B, 0x04050607, 0x00010203);
    ensures
        !is_last ==> Ii == quad32_opt_rev(!rev_bytes, buffer128_read(scratch_b, scratch_index, mem));
        !is_last ==> Z1 == buffer128_read(hkeys_b, power_index, mem);
        !is_last ==> scratch_ptr == old(scratch_ptr) + (if rev_blocks then 0x10 else (-0x10));
        is_last ==> scratch_ptr == old(scratch_ptr); 
        of_quad32(Z0) +. shift(of_quad32(Z2), 64) +. shift(of_quad32(Z3), 128) ==
            ghash_unroll_back(h, prev, pdata, 0, n, #nat(m));
{
    let data_i := #poly(pdata(n - m - 1));
    inline if (is_last)
    {
        VPolyAdd(Ii, Xi, Ii);
    }
    else if (rev_blocks)
    {
        Add64(scratch_ptr, 0x10);
    }
    else
    {
        Sub64(scratch_ptr, 0x10);
    }
    VPolyMul(T1, Ii, Z1, false, false);
    VPolyMul(T2, Ii, Z1, false, true);
    VPolyMul(Hkey, Ii, Z1, true, false);
    VPolyMul(Z1, Ii, Z1, true, true);
    lemma_Mul128_accum(~~Z0, ~~Z2, ~~Z3, (if n = m + 1 then prev +. data_i else data_i), gf128_power(h, #nat(m + 1)));

    inline if (!is_last)
    {
        Load128_buffer(Ii, scratch_ptr, 0, Secret, scratch_b, scratch_index);
        inline if (!rev_bytes)
        {
            Pshufb(Ii, rev_mask);
        }
    }
    inline if (is_first)
    {
        Mov128(Z0, T1);
    }
    else
    {
        VPolyAdd(Z0, Z0, T1);
    }
    inline if (!is_last)
    {
        Load128_buffer(T1, Xip, 0x10 * power_index - 0x20, Secret, hkeys_b, power_index);
    }
    inline if (is_first)
    {
        lemma_Mul128((if n = m + 1 then prev +. data_i else data_i), gf128_power(h, 1));
        VPolyAdd(Z2, T2, Hkey);
        Mov128(Z3, Z1);
    }
    else
    {
        VPolyAdd(Z2, Z2, T2);
        VPolyAdd(Z2, Z2, Hkey);
        VPolyAdd(Z3, Z3, Z1);
    }
    inline if (!is_last)
    {
        Mov128(Z1, T1);
    }
}

procedure MulAdd_unroll_n(
        inline rev_bytes:bool,
        inline rev_blocks:bool,
        inline exactly6:bool,
        ghost scratch_len:nat64,
        ghost hkeys_b:buffer128,
        ghost scratch_b:buffer128,
        ghost h:poly,
        ghost prev:poly,
        ghost data:seq(quad32))
    {:quick}
    lets
        Xip @= r9; n_reg @= rbx; scratch_ptr @= rcx;
        Ii @= xmm0; T1 @= xmm1; T2 @= xmm2; Hkey @= xmm3;
        Z0 @= xmm4; Z1 @= xmm5; Z2 @= xmm6; Z3 @= xmm7;
        Xi @= xmm8; rev_mask @= xmm9;
        pdata := fun_seq_quad32_LE_poly128(data);
        n := length(data);
        scratch_index := index_opt_rev(rev_blocks, scratch_len, n, n - 1);
    reads
        mem; memTaint; Xip; rbp; n_reg; rev_mask;
    modifies
        efl; scratch_ptr; Ii; T1; T2; Hkey; Z0; Z1; Z2; Z3; Xi;
    requires
        pclmulqdq_enabled && avx_enabled;
        exactly6 ==> n == 6;
        !exactly6 ==> 1 <= n < 6;
        n <= scratch_len;
        hkeys_b_powers(hkeys_b, mem, memTaint, Xip - 0x20, h);
        scratch_b_data(rev_bytes, rev_blocks, scratch_b, scratch_len, 6, mem, memTaint, rbp, data);
        buffers_disjoint128(hkeys_b, scratch_b);
        rbp + 0x10 * scratch_len <= pow2_64;
        of_quad32(Xi) == prev;
        !exactly6 ==> n_reg == n;
        scratch_ptr == rbp + 0x10 * scratch_index;
        !rev_bytes ==> rev_mask == Mkfour(0x0C0D0E0F, 0x08090A0B, 0x04050607, 0x00010203);
    ensures
        of_quad32(Z0) +. shift(of_quad32(Z2), 64) +. shift(of_quad32(Z3), 128) ==
            ghash_unroll_back(h, prev, pdata, 0, n, #nat(n - 1));
        exactly6 /\ !rev_blocks ==> scratch_ptr == old(scratch_ptr) - 0x50;
{
    Load128_buffer(Z1, Xip, (-0x20), Secret, hkeys_b, 0);
    // assert of_quad32(Z1) == gf128_power(h, 1);
    Load128_buffer(Ii, scratch_ptr, 0, Secret, scratch_b, scratch_index);
    inline if (!rev_bytes)
    {
        Pshufb(Ii, rev_mask);
    }
    // assert Ii == reverse_bytes_quad32(index(data, #nat(n - 1)));
    inline if (exactly6)
    {
        MulAdd_unroll_i(rev_bytes, rev_blocks, true, false, 1, scratch_len, n, 0, hkeys_b, scratch_b, h, prev, data);
        MulAdd_unroll_i(rev_bytes, rev_blocks, false, false, 3, scratch_len, n, 1, hkeys_b, scratch_b, h, prev, data);
        MulAdd_unroll_i(rev_bytes, rev_blocks, false, false, 4, scratch_len, n, 2, hkeys_b, scratch_b, h, prev, data);
        MulAdd_unroll_i(rev_bytes, rev_blocks, false, false, 6, scratch_len, n, 3, hkeys_b, scratch_b, h, prev, data);
        MulAdd_unroll_i(rev_bytes, rev_blocks, false, false, 7, scratch_len, n, 4, hkeys_b, scratch_b, h, prev, data);
        MulAdd_unroll_i(rev_bytes, rev_blocks, false, true, 0, scratch_len, n, 5, hkeys_b, scratch_b, h, prev, data);
    }
    else
    {
        if (n_reg == 1)
        {
            MulAdd_unroll_i(rev_bytes, rev_blocks, true, true, 1, scratch_len, n, 0, hkeys_b, scratch_b, h, prev, data);
        }
        else
        {
            MulAdd_unroll_i(rev_bytes, rev_blocks, true, false, 1, scratch_len, n, 0, hkeys_b, scratch_b, h, prev, data);
            if (n_reg != 2)
            {
                MulAdd_unroll_i(rev_bytes, rev_blocks, false, false, 3, scratch_len, n, 1, hkeys_b, scratch_b, h, prev, data);
                if (n_reg != 3)
                {
                    MulAdd_unroll_i(rev_bytes, rev_blocks, false, false, 4, scratch_len, n, 2, hkeys_b, scratch_b, h, prev, data);
                    if (n_reg != 4)
                    {
                        MulAdd_unroll_i(rev_bytes, rev_blocks, false, false, 6, scratch_len, n, 3, hkeys_b, scratch_b, h, prev, data);
                    }
                }
            }
            MulAdd_unroll_i(rev_bytes, rev_blocks, false, true, 0, scratch_len, n, n - 1, hkeys_b, scratch_b, h, prev, data);
        }
    }
}

procedure MulAdd_unroll(
        ghost hkeys_b:buffer128,
        ghost scratch_b:buffer128,
        ghost h:poly,
        ghost prev:poly,
        ghost data:seq(quad32))
    {:quick}
    lets
        Xip @= r9;
        Ii @= xmm0; T1 @= xmm1; T2 @= xmm2; Hkey @= xmm3;
        Z0 @= xmm4; Z1 @= xmm5; Z2 @= xmm6; Z3 @= xmm7;
        Xi @= xmm8;
        pdata := fun_seq_quad32_LE_poly128(data);
    reads
        mem; memTaint; Xip; rbp;
    modifies
        efl; rax; Ii; T1; T2; Hkey; Z0; Z1; Z2; Z3; Xi;
    requires
        pclmulqdq_enabled && avx_enabled;
        length(data) == 6;
        hkeys_b_powers(hkeys_b, mem, memTaint, Xip - 0x20, h);
        scratch_b_data(true, true, scratch_b, 8, 5, mem, memTaint, rbp, data);
        Z3 == reverse_bytes_quad32(data[5]);
        buffers_disjoint128(hkeys_b, scratch_b);
        of_quad32(Xi) +. of_quad32(Z0) +. of_quad32(buffer128_read(scratch_b, 1, mem)) == prev;
    ensures
        of_quad32(Z0) +. shift(of_quad32(Z2), 64) +. shift(of_quad32(Z3), 128) ==
            ghash_unroll_back(h, prev, pdata, 0, 6, 5);
        old(buffer128_read(scratch_b, 2, mem)) == buffer128_read(scratch_b, 2, mem);
        Hkey == Mkfour(0, 0, 0, 0xc2000000);
{
    let data0 := #poly(pdata(0));
    let data1 := #poly(pdata(1));
    let data2 := #poly(pdata(2));
    let data3 := #poly(pdata(3));
    let data4 := #poly(pdata(4));
    let data5 := #poly(pdata(5));

    // 1
    Load128_buffer(Hkey, Xip, (-0x20), Secret, hkeys_b, 0);
    VPolyMul(T1, Z3, Hkey, false, false);
    VPolyMul(Z1, Z3, Hkey, false, true);
    Load128_buffer(Ii, rbp, 0x30, Secret, scratch_b, 3);
    VPolyMul(Z2, Z3, Hkey, true, false);
    VPolyMul(Z3, Z3, Hkey, true, true);
    lemma_Mul128(data5, gf128_power(h, 1));
    ghost var z := data5 *. gf128_power(h, 1);
    assert z == ghash_unroll_back(h, prev, pdata, 0, 6, 0);
    // assert z == ~~T1 +. shift(~~Z1 +. ~~Z2, 64) +. shift(~~Z3, 128);
    lemma_add_commute(~~Z1, ~~Z2);
    // assert z == ~~T1 +. shift(~~Z2 +. ~~Z1, 64) +. shift(~~Z3, 128);

    Load128_buffer(Hkey, Xip, (-0x10), Secret, hkeys_b, 1);
    VPolyAdd(Z2, Z2, Z1);
    let z0 := ~~T1;
    // assert z == z0 +. shift(~~Z2, 64) +. shift(~~Z3, 128);

    // 2
    VPolyMul(Z1, Ii, Hkey, false, false);
    VPolyAdd(Xi, Xi, Z0);
    VPolyAdd(Z0, T1, Z1);
    VPolyMul(T1, Ii, Hkey, false, true);
    VPolyMul(T2, Ii, Hkey, true, false);
    VPolyAdd(Xi, Xi, Mem128(rbp, 0x10, Secret, scratch_b, 1));
    // assert ~~Xi == prev;
    VPolyMul(Hkey, Ii, Hkey, true, true);
    lemma_Mul128_accum(z0, ~~Z2, ~~Z3, data4, gf128_power(h, 2));
    z := z +. data4 *. gf128_power(h, 2);
    assert z == ghash_unroll_back(h, prev, pdata, 0, 6, 1);
    // assert z == ~~Z0 +. shift(~~Z2 +. ~~T1 +. ~~T2, 64) +. shift(~~Z3 +. ~~Hkey, 128);

    Load128_buffer(Ii, rbp, 0x40, Secret, scratch_b, 4);
    Load128_buffer(Z1, Xip, 0x10, Secret, hkeys_b, 3);
    VPolyAdd(Z2, Z2, T1);
    // assert z == ~~Z0 +. shift(~~Z2 +. ~~T2, 64) +. shift(~~Z3 +. ~~Hkey, 128);

    // 3
    VPolyMul(T1, Ii, Z1, false, false);
    VPolyAdd(Z2, Z2, T2);
    // assert z == ~~Z0 +. shift(~~Z2, 64) +. shift(~~Z3 +. ~~Hkey, 128);
    VPolyMul(T2, Ii, Z1, false, true);
    VPolyAdd(Z3, Z3, Hkey);
    // assert z == ~~Z0 +. shift(~~Z2, 64) +. shift(~~Z3, 128);
    VPolyMul(Hkey, Ii, Z1, true, false);
    VPolyMul(Z1, Ii, Z1, true, true);
    lemma_Mul128_accum(~~Z0, ~~Z2, ~~Z3, data3, gf128_power(h, 3));
    z := z +. data3 *. gf128_power(h, 3);
    assert z == ghash_unroll_back(h, prev, pdata, 0, 6, 2);
    // assert z == (~~Z0 +. ~~T1) +. shift(~~Z2 +. ~~T2 +. ~~Hkey, 64) +. shift(~~Z3 +. ~~Z1, 128);

    Load128_buffer(Ii, rbp, 0x50, Secret, scratch_b, 5);
    VPolyAdd(Z0, Z0, T1);
    // assert z == ~~Z0 +. shift(~~Z2 +. ~~T2 +. ~~Hkey, 64) +. shift(~~Z3 +. ~~Z1, 128);
    Load128_buffer(T1, Xip, 0x20, Secret, hkeys_b, 4);
    VPolyAdd(Z2, Z2, T2);
    // assert z == ~~Z0 +. shift(~~Z2 +. ~~Hkey, 64) +. shift(~~Z3 +. ~~Z1, 128);

    // 4
    VPolyMul(T2, Ii, T1, false, false);
    VPolyAdd(Z2, Z2, Hkey);
    // assert z == ~~Z0 +. shift(~~Z2, 64) +. shift(~~Z3 +. ~~Z1, 128);
    VPolyMul(Hkey, Ii, T1, false, true);
    VPolyAdd(Z3, Z3, Z1);
    // assert z == ~~Z0 +. shift(~~Z2, 64) +. shift(~~Z3, 128);
    VPolyMul(Z1, Ii, T1, true, false);
    VPolyMul(T1, Ii, T1, true, true);
    lemma_Mul128_accum(~~Z0, ~~Z2, ~~Z3, data2, gf128_power(h, 4));
    z := z +. data2 *. gf128_power(h, 4);
    assert z == ghash_unroll_back(h, prev, pdata, 0, 6, 3);
    // assert z == (~~Z0 +. ~~T2) +. shift(~~Z2 +. ~~Hkey +. ~~Z1, 64) +. shift(~~Z3 +. ~~T1, 128);

    Load128_buffer(Ii, rbp, 0x60, Secret, scratch_b, 6);
    VPolyAdd(Z0, Z0, T2);
    // assert z == ~~Z0 +. shift(~~Z2 +. ~~Hkey +. ~~Z1, 64) +. shift(~~Z3 +. ~~T1, 128);
    Load128_buffer(T2, Xip, 0x40, Secret, hkeys_b, 6);
    VPolyAdd(Z2, Z2, Hkey);
    // assert z == ~~Z0 +. shift(~~Z2 +. ~~Z1, 64) +. shift(~~Z3 +. ~~T1, 128);

    // 5
    VPolyMul(Hkey, Ii, T2, false, false);
    VPolyAdd(Z2, Z2, Z1);
    // assert z == ~~Z0 +. shift(~~Z2, 64) +. shift(~~Z3 +. ~~T1, 128);
    VPolyMul(Z1, Ii, T2, false, true);
    VPolyAdd(Z3, Z3, T1);
    // assert z == ~~Z0 +. shift(~~Z2, 64) +. shift(~~Z3, 128);
    VPolyMul(T1, Ii, T2, true, false);
    VPolyAdd(Xi, Xi, Mem128(rbp, 0x70, Secret, scratch_b, 7));
    VPolyMul(T2, Ii, T2, true, true);
    lemma_Mul128_accum(~~Z0, ~~Z2, ~~Z3, data1, gf128_power(h, 5));
    z := z +. data1 *. gf128_power(h, 5);
    assert z == ghash_unroll_back(h, prev, pdata, 0, 6, 4);
    // assert z == (~~Z0 +. ~~Hkey) +. shift(~~Z2 +. ~~Z1 +. ~~T1, 64) +. shift(~~Z3 +. ~~T2, 128);

    VPolyAdd(Z0, Z0, Hkey);
    // assert z == ~~Z0 +. shift(~~Z2 +. ~~Z1 +. ~~T1, 64) +. shift(~~Z3 +. ~~T2, 128);
    Load128_buffer(Hkey, Xip, 0x50, Secret, hkeys_b, 7);
    VPolyAdd(Z2, Z2, Z1);
    // assert z == ~~Z0 +. shift(~~Z2 +. ~~T1, 64) +. shift(~~Z3 +. ~~T2, 128);

    // 6
    VPolyMul(Z1, Xi, Hkey, false, true);
    VPolyAdd(Z2, Z2, T1);
    // assert z == ~~Z0 +. shift(~~Z2, 64) +. shift(~~Z3 +. ~~T2, 128);
    VPolyMul(T1, Xi, Hkey, true, false);
    VPolyAdd(Z3, Z3, T2);
    // assert z == ~~Z0 +. shift(~~Z2, 64) +. shift(~~Z3, 128);
    VPolyMul(T2, Xi, Hkey, false, false);
    VPolyMul(Xi, Xi, Hkey, true, true);
    lemma_Mul128_accum(~~Z0, ~~Z2, ~~Z3, prev +. data0, gf128_power(h, 6));
    z := z +. (prev +. data0) *. gf128_power(h, 6);
    assert z == ghash_unroll_back(h, prev, pdata, 0, 6, 5);
    // assert z == (~~Z0 +. ~~T2) +. shift(~~Z2 +. ~~Z1 +. ~~T1, 64) +. shift(~~Z3 +. ~~Xi, 128);

    VPolyAdd(Z2, Z2, Z1);
    // assert z == (~~Z0 +. ~~T2) +. shift(~~Z2 +. ~~T1, 64) +. shift(~~Z3 +. ~~Xi, 128);
    VPolyAdd(Z2, Z2, T1);
    // assert z == (~~Z0 +. ~~T2) +. shift(~~Z2, 64) +. shift(~~Z3 +. ~~Xi, 128);
    // vpslldq in Reduce
    VPolyAdd(Z0, Z0, T2);
    // assert z == ~~Z0 +. shift(~~Z2, 64) +. shift(~~Z3 +. ~~Xi, 128);
    ZeroXmm(Hkey);
    PinsrdImm(Hkey, 0xc2000000, 3, rax); // REVIEW: vmovdqu into Hkey
    VPolyAdd(Z3, Z3, Xi);

    // assert z == ~~Z0 +. shift(~~Z2, 64) +. shift(~~Z3, 128);
}

procedure Reduce(ghost f:poly)
    {:quick}
    lets
        Ii @= xmm0; Hkey @= xmm3;
        Z0 @= xmm4; Z1 @= xmm5; Z2 @= xmm6; Z3 @= xmm7;
        Xi @= xmm8;
        g := monomial(128) +. f;
        c := reverse(shift(f, (-1)), 63);
        a0 := of_quad32(Z0);
        a1 := of_quad32(Z2);
        a2 := of_quad32(Z3);
        a := a0 +. shift(a1, 64) +. shift(a2, 128);
    modifies
        efl; Ii; Hkey; Z0; Z1; Z2; Z3; Xi;
    requires
        pclmulqdq_enabled && avx_enabled;
        shift(of_quad32(Hkey), (-64)) == c;
        degree(f) < 64;
        degree(g) == 128;
        poly_index(f, 0);
    ensures
        of_quad32(Xi) == reverse(reverse(a, 255) %. g, 127);
{
    VLow64ToHigh(Z1, Z2);
    VPolyAdd(Z0, Z0, Z1);
    VSwap(Ii, Z0);
    VPolyMul(Z0, Z0, Hkey, false, true);
    VHigh64ToLow(Z2, Z2);
    VPolyAdd(Z3, Z3, Z2);
    VPolyAdd(Z0, Ii, Z0);
    // TODO: save Z3 in memory
    VSwap(Xi, Z0);
    VPolyMul(Z0, Z0, Hkey, false, true);
    VPolyAdd(Xi, Xi, Z3);
    VPolyAdd(Xi, Xi, Z0);
    lemma_reduce_rev(a0, a1, a2, f, 64);
}

procedure GhashUnroll_n(
        inline rev_bytes:bool,
        inline rev_blocks:bool,
        inline exactly6:bool,
        ghost scratch_len:nat64,
        ghost hkeys_b:buffer128,
        ghost scratch_b:buffer128,
        ghost h_LE:quad32,
        ghost y_prev:quad32,
        ghost data:seq(quad32))
    {:public}
    {:quick}
    lets
        Xip @= r9; n_reg @= rbx; scratch_ptr @= rcx; scratch_reg @= rdx;
        Ii @= xmm0; T1 @= xmm1; T2 @= xmm2; Hkey @= xmm3;
        Z0 @= xmm4; Z1 @= xmm5; Z2 @= xmm6; Z3 @= xmm7;
        Xi @= xmm8; rev_mask @= xmm9;
        h := of_quad32(reverse_bytes_quad32(h_LE));
        prev := of_quad32(reverse_bytes_quad32(y_prev));
        pdata := fun_seq_quad32_LE_poly128(data);
        n := length(data);
        scratch_index := index_opt_rev(rev_blocks, scratch_len, n, n - 1);
    reads
        mem; memTaint; Xip; n_reg; rbp; rev_mask;
    modifies
        efl; scratch_reg; scratch_ptr; Ii; T1; T2; Hkey; Z0; Z1; Z2; Z3; Xi;
    requires
        pclmulqdq_enabled && avx_enabled;
        exactly6 ==> n == 6;
        !exactly6 ==> 1 <= n < 6;
        n <= scratch_len;
        hkeys_b_powers(hkeys_b, mem, memTaint, Xip - 0x20, h);
        scratch_b_data(rev_bytes, rev_blocks, scratch_b, scratch_len, 6, mem, memTaint, rbp, data);
        buffers_disjoint128(hkeys_b, scratch_b);
        rbp + 0x10 * scratch_len <= pow2_64;
        of_quad32(Xi) == prev;
        !exactly6 ==> n_reg == n;
        scratch_ptr == rbp + 0x10 * scratch_index;
        !rev_bytes ==> rev_mask == Mkfour(0x0C0D0E0F, 0x08090A0B, 0x04050607, 0x00010203);
    ensures
        Xi == reverse_bytes_quad32(ghash_incremental(h_LE, y_prev, data));
        exactly6 /\ !rev_blocks ==> scratch_ptr == old(scratch_ptr) - 0x50;
{
    MulAdd_unroll_n(rev_bytes, rev_blocks, exactly6, scratch_len, hkeys_b, scratch_b, h, prev, data);
    ZeroXmm(Hkey);
    PinsrdImm(Hkey, 0xc2000000, 3, scratch_reg);
    lemma_gf128_low_shift();
    lemma_gf128_degree();
    Reduce(gf128_modulus_low_terms);
    // assert of_quad32(Xi) == mod_rev(128, ghash_unroll_back(h, prev, pdata, 0, n, #nat(n - 1)), gf128_modulus);
    lemma_ghash_unroll_back_forward(h, prev, pdata, 0, #nat(n - 1));
    // assert of_quad32(Xi) == mod_rev(128, ghash_unroll(h, prev, pdata, 0, #nat(n - 1), 0), gf128_modulus);
    lemma_ghash_poly_of_unroll(h, prev, pdata, 0, #nat(n - 1));
    // assert of_quad32(Xi) == ghash_poly(h, prev, pdata, 0, n);
    lemma_ghash_incremental_poly(h_LE, y_prev, data);
    // assert of_quad32(Xi) == of_quad32(reverse_bytes_quad32(ghash_incremental(h_LE, y_prev, data)));
    lemma_to_of_quad32(reverse_bytes_quad32(ghash_incremental(h_LE, y_prev, data)));
}

// TODO: Pair this up with a version of gcm_make_length_quad that doesn't reverse it's output,
//       since that reversal will cancel with this one

// Expects input to be hashed to reside in Ii
procedure Ghash_register(
        ghost hkeys_b:buffer128,
        ghost scratch_b:buffer128,
        ghost h_LE:quad32,
        ghost y_prev:quad32)
    {:public}
    {:quick}
    lets
        Xip @= r9; scratch_ptr @= rcx;
        Ii @= xmm0; T1 @= xmm1; T2 @= xmm2; Hkey @= xmm3;
        Z0 @= xmm4; Z1 @= xmm5; Z2 @= xmm6; Z3 @= xmm7;
        Xi @= xmm8;
        h := of_quad32(reverse_bytes_quad32(h_LE));
        data := create(1, reverse_bytes_quad32(Ii));
        prev := of_quad32(reverse_bytes_quad32(y_prev));
        pdata := fun_seq_quad32_LE_poly128(data);
    reads
        mem; memTaint; Xip; rbp; 
    modifies
        efl; scratch_ptr; Ii; T1; T2; Hkey; Z0; Z1; Z2; Z3; Xi;
    requires
        pclmulqdq_enabled && avx_enabled;
        hkeys_b_powers(hkeys_b, mem, memTaint, Xip - 0x20, h);
        of_quad32(Xi) == prev;
    ensures
        Xi == reverse_bytes_quad32(ghash_incremental(h_LE, y_prev, old(data)));
{
    Load128_buffer(Z1, Xip, (-0x20), Secret, hkeys_b, 0);
    assert of_quad32(Z1) == gf128_power(h, 1);

    assert Ii == reverse_bytes_quad32(index(data, #nat(0)));
    let data_i := #poly(pdata(0));
    VPolyAdd(Ii, Xi, Ii);
    VPolyMul(T1, Ii, Z1, false, false);
    VPolyMul(T2, Ii, Z1, false, true);
    VPolyMul(Hkey, Ii, Z1, true, false);
    VPolyMul(Z1, Ii, Z1, true, true);
    lemma_Mul128_accum(~~Z0, ~~Z2, ~~Z3, prev +. data_i, gf128_power(h, 1));
    Mov128(Z0, T1);
    lemma_Mul128(prev +. data_i, gf128_power(h, 1));
    VPolyAdd(Z2, T2, Hkey);
    Mov128(Z3, Z1);
    ZeroXmm(Hkey);
    PinsrdImm(Hkey, 0xc2000000, 3, scratch_ptr);
    lemma_gf128_low_shift();
    lemma_gf128_degree();
    Reduce(gf128_modulus_low_terms);
    assert of_quad32(Xi) == mod_rev(128, ghash_unroll_back(h, prev, pdata, 0, 1, 0), gf128_modulus);
    lemma_ghash_unroll_back_forward(h, prev, pdata, 0, 0);
    assert of_quad32(Xi) == mod_rev(128, ghash_unroll(h, prev, pdata, 0, 0, 0), gf128_modulus);
    lemma_ghash_poly_of_unroll(h, prev, pdata, 0, 0);
    assert of_quad32(Xi) == ghash_poly(h, prev, pdata, 0, 1);
    lemma_ghash_incremental_poly(h_LE, y_prev, data);
    assert of_quad32(Xi) == of_quad32(reverse_bytes_quad32(ghash_incremental(h_LE, y_prev, data)));
    lemma_to_of_quad32(reverse_bytes_quad32(ghash_incremental(h_LE, y_prev, data)));
}

#reset-options "--z3rlimit 30"
procedure Ghash_buffer(
        ghost hkeys_b:buffer128,
        ghost in_b:buffer128,
        ghost h_LE:quad32,
        ghost y_prev:quad32
        )
    //{:public}
    //{:quick}
    lets
        Xip @= r9; len @= rbx; scratch_ptr @= rcx; in_ptr @= rbp; scratch_reg @= rdx;
        Ii @= xmm0; T1 @= xmm1; T2 @= xmm2; Hkey @= xmm3;
        Z0 @= xmm4; Z1 @= xmm5; Z2 @= xmm6; Z3 @= xmm7;
        Xi @= xmm8; rev_mask @= xmm9;
        h := of_quad32(reverse_bytes_quad32(h_LE));
        prev := of_quad32(reverse_bytes_quad32(y_prev));
    reads
        Xip; in_ptr; rev_mask; mem; memTaint; 
    modifies
        len; scratch_ptr; scratch_reg; efl; Ii; T1; T2; Hkey; Z0; Z1; Z2; Z3; Xi;
    requires
        pclmulqdq_enabled && avx_enabled;
        hkeys_b_powers(hkeys_b, mem, memTaint, Xip - 0x20, h);
        validSrcAddrs128(mem, in_ptr, in_b, len, memTaint, Secret);
        buffer_length(in_b) == len;
        buffers_disjoint128(hkeys_b, in_b);
        in_ptr + 0x10 * len <= pow2_64;
        of_quad32(Xi) == prev;
        rev_mask == Mkfour(0x0C0D0E0F, 0x08090A0B, 0x04050607, 0x00010203);

        //0 < len < 6;
        //len == 6;
    ensures
//        Xi == reverse_bytes_quad32(ghash_incremental(h_LE, y_prev, s128(mem, in_b)));
{
//    Mov64(scratch_ptr, len);
//    Sub64(scratch_ptr, 1);
//    IMul64(scratch_ptr,  0x10);
//    Add64(scratch_ptr, in_ptr);

    //if (len >= 6) {
        Mov64(scratch_ptr, in_ptr);
    //    Add64(scratch_ptr, 0x60);
    //}

    ghost var index:nat := 0;
    while (len >= 6) 
        invariant 
            // Loop invariants
            //index + 6 <= old(len);
            6*index + len == old(len);
            scratch_ptr == in_ptr + 0x10 * index;
            len >= 0;

            // Copy over preconditions
            pclmulqdq_enabled && avx_enabled;
            hkeys_b_powers(hkeys_b, mem, memTaint, Xip - 0x20, h);
            validSrcAddrs128(mem, in_ptr, in_b, len, memTaint, Secret);
            buffer_length(in_b) == old(len);
            buffers_disjoint128(hkeys_b, in_b);
            in_ptr + 0x10 * old(len) < pow2_64;
            Xi == reverse_bytes_quad32(ghash_incremental0(h_LE, y_prev, slice(s128(mem, in_b), 0, index)));
            rev_mask == Mkfour(0x0C0D0E0F, 0x08090A0B, 0x04050607, 0x00010203);
            
        decreases
            len;
    {
        let data := Seq.slice(s128(mem, in_b), index, index + 6);
        Add64(scratch_ptr, 0x50);
//        assert validSrcAddrs128(mem,rbp, in_b, 6, memTaint, Secret);
////        assert forall (i:nat) i < 6 /\ i < length(data) ==>
////               buffer128_read(in_b, index_opt_rev(false, 6, length(data), i), mem) ==
////               quad32_opt_rev(false, Seq.index(data, i));
////
//        assert scratch_b_data(false, false, in_b, index + 6, 6, mem, memTaint, rbp, data);
//        assume false;
        GhashUnroll_n(false, false, true, #nat64(index+6), hkeys_b, in_b, h_LE, ghash_incremental0(h_LE, y_prev, slice(s128(mem, in_b), 0, index)), data);
        Add64(scratch_ptr, 0x60);
        Sub64(len, 6);
        index := index + 6;
        assume false;
    }

//    if (len > 0) {
//        let data := Seq.slice(s128(mem, in_b), 0, len);
////        Mov64(scratch_ptr, len);
////        Sub64(scratch_ptr, 1);
////        IMul64(scratch_ptr,  0x10);
////        Add64(scratch_ptr, in_ptr);
//        GhashUnroll_n(false, false, false, len, hkeys_b, in_b, h_LE, y_prev, data);
//    }

}

procedure GhashUnroll6x(
        ghost hkeys_b:buffer128,
        ghost scratch_b:buffer128,
        ghost h_LE:quad32,
        ghost y_prev:quad32,
        ghost data:seq(quad32))
    {:public}
    {:quick}
    lets
        Xip @= r9;
        Ii @= xmm0; T1 @= xmm1; T2 @= xmm2; Hkey @= xmm3;
        Z0 @= xmm4; Z1 @= xmm5; Z2 @= xmm6; Z3 @= xmm7;
        Xi @= xmm8;
        h := of_quad32(reverse_bytes_quad32(h_LE));
        prev := of_quad32(reverse_bytes_quad32(y_prev));
        pdata := fun_seq_quad32_LE_poly128(data);
    reads
        mem; memTaint; Xip; rbp;
    modifies
        efl; rax; Ii; T1; T2; Hkey; Z0; Z1; Z2; Z3; Xi;
    requires
        pclmulqdq_enabled && avx_enabled;
        length(data) == 6;
        hkeys_b_powers(hkeys_b, mem, memTaint, Xip - 0x20, h);
        scratch_b_data(true, true, scratch_b, 8, 5, mem, memTaint, rbp, data);
        Z3 == reverse_bytes_quad32(data[5]);
        buffers_disjoint128(hkeys_b, scratch_b);
        of_quad32(Xi) +. of_quad32(Z0) +. of_quad32(buffer128_read(scratch_b, 1, mem)) == prev;
    ensures
        Xi == reverse_bytes_quad32(ghash_incremental(h_LE, y_prev, data));
//        old(buffer128_read(scratch_b, 2, mem)) == buffer128_read(scratch_b, 2, mem);
{
    MulAdd_unroll(hkeys_b, scratch_b, h, prev, data);
    lemma_gf128_low_shift();
    lemma_gf128_degree();
    Reduce(gf128_modulus_low_terms);
    // assert of_quad32(Xi) == mod_rev(128, ghash_unroll_back(h, prev, pdata, 0, 6, 5), gf128_modulus);
    lemma_ghash_unroll_back_forward(h, prev, pdata, 0, 5);
    // assert of_quad32(Xi) == mod_rev(128, ghash_unroll(h, prev, pdata, 0, 5, 0), gf128_modulus);
    lemma_ghash_poly_of_unroll(h, prev, pdata, 0, 5);
    // assert of_quad32(Xi) == ghash_poly(h, prev, pdata, 0, 6);
    lemma_ghash_incremental_poly(h_LE, y_prev, data);
    // assert of_quad32(Xi) == of_quad32(reverse_bytes_quad32(ghash_incremental(h_LE, y_prev, data)));
    lemma_to_of_quad32(reverse_bytes_quad32(ghash_incremental(h_LE, y_prev, data)));
}
